A*. Вектор
Ограничение времени	0.1 секунда
Ограничение памяти	8Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Даны два ненулевых вектора. Требуется вычислить:

Длину первого и второго вектора (два числа)
Вектор, образованный сложением данных двух векторов
Скалярное и векторное произведения данных векторов
Площадь треугольника, построенного из этих векторов
В общем, обычная векторная жизнь.

Формат ввода
В двух строках входного файла заданы по четыре целых числа, не превосходящих по модулю 10 000, — координаты начала и конца первого вектора, затем второго.

Формат вывода
В каждой строке выходного файла — ответ на соответствующий пункт задачи с точностью не менее 10-6.

B*. Две прямые
Ограничение времени	0.1 секунда
Ограничение памяти	8Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Даны коэффициенты A1, B1, C1 уравнения первой прямой и коэффициенты A2, B2, C2 уравнения второй прямой. Требуется:

Построить направляющие векторы для обеих прямых (вывести координаты)
Найти точку пересечения двух прямых или вычислить расстояние между ними, если они параллельны
Формат ввода
В первой строке входного файла находятся три числа — коэффициенты нормального уравнения для первой прямой. Во второй строке — коэффициенты для второй прямой.

Все числа во входном файле по модулю не превосодят 10 000.

Формат вывода
В каждой строке выходного файла выведите ответ на соответствующий пункт задачи с точностью до 10-6.

C*. Точка и две точки
Ограничение времени	0.1 секунда
Ограничение памяти	8Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Определите, принадлежит ли точка C заданной прямой, лучу и отрезку, образованными точками A и B.

Задумайтесь принадлежит ли вам ваша жизнь.

Формат ввода
В первой строке входного файла даны два целых числа — координаты точки C. Во двух следующих строках в таком же формате заданы точки A и B (A ≠ B).

Все числа во входном файле по модулю не превосодят 10 000.

Формат вывода
В первой строке выведите «YES», если точка C принадлежит прямой AB, и «NO» в противном случае. Во второй и третьей строках аналогично выведите ответы для луча AB (A — начало луча) и отрезка AB.

D*. Расстояния
Ограничение времени	0.1 секунда
Ограничение памяти	8Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Даны три точки A, B и C. Необходимо подсчитать расстояния от точки C до прямой, луча и отрезка, образованного точками A и B.

Формат ввода
В первой строке входного файла даны два целых числа — координаты точки C. Во двух следующих строках в таком же формате заданы точки A и B (A ≠ B).

Все числа во входном файле по модулю не превосодят 10 000.

Формат вывода
В первой строке выходного файла выведите одно вещественное число — расстояние от точки C до прямой. В следующих двух строках выведите соответственно расстояния до луча AB (A — начало луча) и до отрезка AB. Все числа выводить с точностью не менее 10-6. Луч строится по направлению от точки A к точке B.

E*. Два отрезка
Ограничение времени	0.1 секунда
Ограничение памяти	8Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Необходимо проверить, пересекаются ли два отрезка.

Формат ввода
В двух строках входного файла заданы по четыре целых числа, не превосходящих по модулю 10 000, — координаты концов первого отрезка, затем второго.

Формат вывода
В первой строке выходного файла выведите «YES», если отрезки имеют общие точки, и «NO» в противном случае.

F*. Отрезки на дистанции
Ограничение времени	0.1 секунда
Ограничение памяти	8Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Найдите расстояние между двумя отрезками.

Формат ввода
В двух строках входного файла даны по четыре целых числа, не превосходящих по модулю 10 000, — координаты концов сначала первого, затем второго отрезков.

Формат вывода
В первой строке выходного файла выведите одно вещественное число — расстояние между отрезками с точностью не менее 10-6.

G. (Не)выпуклый
Ограничение времени	0.5 секунд
Ограничение памяти	16Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Проверьте многоугольник на выпуклость. Задумайтесь над тем, что в 1863 году слово "впуклый" использовалось наравне с словом "выпуклый", но за следующие двести лет сокрушительно проиграло конкуренцию букве "ы".

Формат ввода
В первой строке одно число N (3 ≤ N ≤ 100000). Далее в N строках по паре целых чисел — координаты очередной вершины простого многоугольника в порядке обхода по или против часовой стрелки.

Координаты всех точек целые, по модулю не превосходят 107.

Формат вывода
Одна строка «YES», если приведённый многоугольник является выпуклым, и «NO» в противном случае.

H. Внутри или нет?
Ограничение времени	0.5 секунд
Ограничение памяти	16Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Проверьте, лежит ли точка внутри многоугольника.

Формат ввода
В первой строке вводятся три целых числа – N () и координаты точки. Далее в N строках задается по паре целых чисел – координаты очередной вершины простого многоугольника в порядке обхода по или против часовой стрелки.

Формат вывода
Выведите одну строку: «YES», если заданная точка содержится в приведённом многоугольнике или на его границе, и «NO» в противном случае.

I. Площадь
Ограничение времени	0.5 секунд
Ограничение памяти	16Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Ежегодно в Бостоне совершается более 300 ограблений банков. Большинство этих профессионалов живут в районе с площадью в всего S квадратных миль под названием Чарльзтаун. Найдите эту площадь.

Формат ввода
В первой строке одно число N (3 ≤ N ≤ 100 000). Далее в N строках по паре чисел — координаты очередной вершины простого многоугольника в порядке обхода по или против часовой стрелки.

Координаты целые, по модулю не превосходящие 1018.

Формат вывода
Одно число — величина площади приведённого многоугольника с точностью 1 знак после запятой.

J*. Geometry
Ограничение времени	0.3 секунд
Ограничение памяти	32.0 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt

В этой задаче необходимо реализовать набор классов для решения геометрических задач на плоскости. Все координаты предполагаются целочисленными.

Vector
Реализовать класс Vector для вектора на плоскости с необходимыми арифметическими операциями (унарные и бинарные +/-, умножение/деление на скаляр, присваивающие версии операций, сравнение на равенство).

Shape
Создать набор классов-фигур, которые наследуются от абстрактного базового класса IShape для работы с двумерными геометрическими примитивами:

Point (точка);
Segment (отрезок);
Line (линия);
Ray (луч);
Polygon (простой многоугольник - часть плоскости, ограниченная замкнутой ломаной без самопересечений);
Circle (окружность).
В базовом классе IShape предусмотреть чисто виртуальные методы:

Move(const Vector&) - сдвига на заданный вектор, метод должен изменять состояние объекта и возвращать ссылку на сам объект;
ContainsPoint(const Point&) - проверка (true/false) содержит ли фигура (внутренность фигуры) точку;
CrossesSegment(const Segment&) проверка (true/false) пересекается ли фигура (граница фигуры) с отрезком;
Clone() - копирование объекта (необходимо вернуть умный или обычный указатель на копию фигуры);
ToString() - строковое представление фигуры (формат см. в примерах).
В производных классах - реализовать эти методы. Разность двух точек должна возвращать вектор перемещения одной точки в другую.

Детали
Все классы должны располагаться в пространстве имен geometry.

С публичным интерфейсом классов, который используется в задаче, подробнее можно ознакомиться в файле geometry_main.cpp. В частности, Point должен уметь конструироваться от двух целых чисел, Segment, Line и Ray - от двух Point, многоугольник - от std::vector<Point>, окружность - от центра (Point) и радиуса (int).

Объявления классов расположите в соответствующих .h файлах, а необходимые файлы реализации положите в папку src. После этого вы можете запустить geometry_public_test (по обычной инструкции - через терминал, либо с помощью IDE) и протестировать на различных входных данных. Вы можете прочитать, что принимает программа на вход из файла geometry_main.cpp и найти примеры корректной работы на странице задачи в контесте.

Формат ввода
В первой строчке задается тип геометрического примитива: «point», «segment», «ray», «line», «circle» или «polygon». Далее вводится сам примитив.

После чего вводится две точки 
A
A и 
B
B, которые используются в 
C
h
e
c
k
F
u
n
c
t
i
o
n
s
CheckFunctions. Все числа целочисленные и не превосходят 10000 по модулю.

Для Point выводятся ее координаты; Segment - два конца (точки); Ray - начало (точка) и направляющий вектор; Line - коэффициенты уравнения прямой (ax + by + c) с точностью до некоторого множителя (по идее система должна принимать и Line(1, −1, 1), и Line(−2, 2, −2)); Polygon - последовательность вершин; Circle - центр и радиус.

K*. Выпуклая оболочка
Ограничение времени	1 секунда
Ограничение памяти	256Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Дано N точек на плоскости. Нужно построить их выпуклую оболочку, используя алгоритм Грэхема.

Гарантируется, что выпуклая оболочка не вырождена.

Формат ввода
На первой строке число N (3 ≤ N ≤ 105). Следующие N строк содержат пары целых чисел x и y (-109 ≤ x, y ≤ 109) — точки.

Будьте аккуратны! Точки произвольны. Бывают совпадающие, бывают лежащие на одной прямой в большом количестве.

Формат вывода
В первой строке выведите K — число вершин выпуклой оболочки. Следующие K строк должны содержать координаты вершин в порядке обхода. Никакие три подряд идущие точки не должны лежать на одной прямой.

Кроме того, в последней строке выведите площадь получившейся выпуклой оболочки. Площадь необходимо вывести c точностью 1 знак после запятой.

L. Выпуклая оболочка. Возвращение легенды
Ограничение времени	1 секунда
Ограничение памяти	256Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Дано N точек на плоскости. Нужно построить их выпуклую оболочку. Всё то же самое, но по-другому. В этот раз реализуйте алгоритм Джарвиса.

Гарантируется, что выпуклая оболочка не вырождена.

Формат ввода
На первой строке число N (3 ≤ N ≤ 105). Следующие N строк содержат пары целых чисел x и y (-109 ≤ x, y ≤ 109) — точки.

Будьте аккуратны! Точки произвольны. Бывают совпадающие, бывают лежащие на одной прямой в большом количестве.

Формат вывода
В первой строке выведите K — число вершин выпуклой оболочки. Следующие K строк должны содержать координаты вершин в порядке обхода. Никакие три подряд идущие точки не должны лежать на одной прямой.

Кроме того, в последней строке выведите площадь получившейся выпуклой оболочки. Площадь необходимо вывести c точностью 1 знак после запятой.

M. Инфекция
Ограничение времени	3 секунды
Ограничение памяти	32Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Неизвестная инфекция начала распространяться по всей столице. Известно, что она распространяется почти одинаково во все стороны, поэтому было решено разбить город на зоны, чтобы лучше мобилизовать ресурсы в случае внештатной ситуации.

Студент Артур долго работал над такой моделью и выяснил, что лучше всего разбить город следующим образом. Задано множество точек размера N — социально значимых объектов в столице. По этому множеству точек разбиение строится так:

строится выпуклая оболочка на этом множестве, потом все точки, что в нее попали (или на ее границу) выбрасываются.
повторяют первый шаг, пока не останется два или меньше социально значимых объектов.
То есть по индукции построили множество выпуклых оболочек. Точка лежит в зоне с номером i, если она лежит внутри i-й оболочки и не лежит внутри (i+1)-й оболочки. Точка лежит в оболочке, если попадает на ее границу или лежит внутри. Зоны нумеруются с нуля, так как там еще нет инфекции.

Ученые заинтересовались его исследованием и решили, что это действительно хорошая модель разбиения, так как точки подобраны согласно последним данным о распространении инфекции. Теперь им стало интересно, в какой зоне будут лежать научно важные объекты, например, университеты или лаборатории. Всего таких объектов K, а так как таких объектов очень много, ученые попросили автоматизировать процесс. Справитесь ли вы с этим поручением?

Формат ввода
В первой строке вам дается число N (3 ≤ N ≤ 103) — количество социально значимых объектов для разбиения города на зоны.

Далее идут N строк по два целых числа через пробел (xi, yi) (-109 ≤ xi, yi ≤ 109) — координаты очередного социально значимого объекта. Гарантируется, что одинаковых точек нет. Считайте, что точки, лежащие снаружи нулевой оболочки лежат в нулевой зоне.

На следующей строке идет число K (1 ≤ K ≤ 105) — количество научно значимых объектов, про которые ученым надо знать их зону.

Далее идут K строк по два целых числа через пробел (xi, yi) (-109 ≤ xi, yi ≤ 109) — координаты университетов, лабораторий …

Формат вывода
Выведите K строк из одного целого числа, где на i-й строке номер зоны i-го научно значимого объекта.

N. Радио
Ограничение времени	3 секунды
Ограничение памяти	32.0 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Компания «Аудио Квадрат» захватила значительную долю рынка музыкальных товаров и услуг. В частности она делает персональное радио для каждого человека, которое учитывает его музыкальные предпочтения и текущее настроение.

Но параллельно, just for fun, компания запускает проект общественного радио. Это радио, в котором песня выбирается в соответствии с пожеланиями множества проголосовавших пользователей.

Алгоритм общественного радио безумно прост. Посетители интернет сайта «Аудио Квадрата» постоянно голосуют за отдельные композиции (с одного IP можно проголосовать в течении 10 минут только за одну композицию). Голос может иметь вес score. Для каждой композиции считаются очки — track_score. Следующей композицией, которая будет играть на радио, станет та, которая имеет максимальное количество очков. Если таких композиций несколько, то должна играть та, которая имеет минимальный идентификатор. В момент, когда композиция запускается на радио, её track_score становится равным -1.

Чтобы исключить попытки накручивания счётчика определёнными группами лиц, компания решила принимать голоса с одного IP не чаще раза в 10 минут (два голоса могут быть приняты, если между ними не менее шестисот секунд).

Вы являетесь главным разработчиком компании «Аудио Квадрат». И хотя у вас в подчинении множество высококлассных программистов, вы решили вспомнить старые добрые времена и запрограммировать этот алгоритм сами.

Общественных радио будет много, поэтому важно, чтобы каждое из них работало достаточно эффективно, то есть не отнимало много процессорных ресурсов и оперативной памяти.

Необходимо написать программу, реализующую алгоритм работы одного общественного радио. Взаимодействие с программой будет осуществляться через стандартный поток ввода/вывода согласно заданному ниже протоколу.

Для решения этой задачи используйте ассоциативные контейнеры и очереди с приоритетами.

Формат ввода
Каждая строчка входа — это определенная команда. Всего 3 типа команд:

VOTE ip track_id score time
GET
EXIT
Команда V OT E меняет число очков track_score определённой композиции. Она получает четыре аргумента:

• ip — IP адрес компьютера, с которого пришел голос; четыре целых числа из промежутка [0, 255], разделённых точкой

• track_id — численный идентификатор композиции; натуральное число из отрезка [1, 2 · 107 ];

• score — количество очков, которое нужно добавить к текущим очкам композиции track_score — целое число из отрезка [−100, 100];

• time — момент времени в секундах от некоторого фиксированного момента времени — целое число из промежутка [0, 2 · 109 ].

На команду VOTE нужно отвечать новым значением очков музыкальной композиции track_id (даже если эти очки не изменились).

Команда GET используется для получения следующей композиции. Ваша программа должна отвечать на неё парой track_id и track_score (вывести эти два числа в одной строке, разделив их пробелом). Сразу после выполнения этой команды новое значение track_score для этой композиции должно стать равным -1.

Команда EXIT находится в последней строке входа. При её получении необходимо вывести строку «OK». Число команд на входе не более 100001. Изначально значение track_score для всех композиций равно 0.

Команды во входных данных упорядочены по параметру time (для двух из трёх команд этот параметр просто не передаётся, так как не нужен).

Формат вывода
Выход должен содержать ровно столько же строчек, что и вход. Каждая строчка выхода — это ответ на соответствующую команду из входа.

O. FrozenSet
Ограничение времени	3 секунды
Ограничение памяти	256.0 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt

Пришлите архив с файлами frozen_set.h, universal_hash.h и, возможно, другими файлами реализации.

FrozenSet
Реализуйте шаблонный класс FrozenSet, который представляет собой структуру данных для хранения фиксированного набора ключей с линейным (в среднем) временем построения, линейными в худшем случае затратами по памяти и константным в худшем случае поиском элемента. Аналог в Python: https://docs.python.org/3/library/stdtypes.html#frozenset.

Несмотря на то, что тесты проверяют корректность решения только на множестве целых неотрицательных чисел не превосходящих 
‘
1
0
9
‘
‘10 
9
 ‘, класс должен уметь работать с объектами произвольных типов (при условии передачи корректного класса хеш функций).

Детали реализации
Хеш-таблица

Предлагается использовать алгоритм FKS, который был рассмотрен на лекции. Класс должен быть параметризован типом ключа, хеш-функции и поддерживать следующий функционал:

Конструктор по умолчанию. Создается пустое множество;
Конструктор от пары итераторов (начало и конец сохраняемой последовательности) и генератора псевдослучайных чисел (см. ниже). Сохраняет элементы переданного промежутка, используя генератор для подбора хеш-функций. Итераторы удовлетворяют категории ForwardIterator, гарантируется, что последовательность не содержит одинаковых ключей;
Методы Size, Empty, Clear с привычной семантикой;
Метод bool Find(key). Осуществляет поиск элемента во множестве.
При хранении элементов в хеш таблицах второго уровня важно отличать заполненные ячейки от незаполненных. Хранение специальных значений (например, -inf для чисел или пустых строк для std::string) обладает очевидным недостатком: невозможно распознать ситуацию, при которой специальное значение в действительности входит во множество хранимых ключей. Для решения этой проблемы предлагается хранить объекты std::optional<T>, которые дополнительно хранят состояние has_value, сообщающее о том было ли установлено значение данного объекта или нет (подробности в задаче Optional).

Хеш-функция

Дополнительно реализуйте класс UniversalHash, представляющий универсальное семейство линейных хеш-функций по некоторому простому модулю (разбиралось на лекции). Интерфейс класса:

Конструктор от двух аргументов (коэффициенты линейной функции) со значениями по умолчанию 1 и 0 (для коэффициента перед x и свободного члена соответственно);
Перегруженная операция функционального вызова от числа;
Статическая константа kMaxValue
максимальное значение хеш-функции (на единицу меньше простого модуля);
Статическая функция GenerateHash(generator), принимающая генератор псевдослучайных чисел и возвращающая случайную хеш-функцию (объект со случайными коэффициентами).