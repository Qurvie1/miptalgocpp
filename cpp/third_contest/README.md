A*. Rational
Ограничение времени	1 секунда
Ограничение памяти	64.0 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
https://gitlab.com/ibr11/cpp_psami_base_2023/-/tree/main/rational

В качестве решения ожидается zip архив с решением (даже если решение состоит из одного файла). Присылайте файлы только с ВАШИМ кодом, то есть файлы с тестами и CMakeLists.txt присылать не нужно.

Условие
В C++ существует множество встроенных типов данных для работы с целочисленной арифметикой и арифметикой над числами с плавающей точкой. Однако при вычислениях над последними возможны ошибки округления, которые могут накапливаться при сложных (состоящих из множества операций) вычислениях. Если при работе с иррациональными числами округлений избежать не получится, то в программах, требующих манипуляций только с рациональными числами, все вычисления можно свести к точной целочисленной арифметике. Именно это вам и предстоит проделать в данном задании.

Детали реализации
Необходимо реализовать класс для работы с рациональными числами Rational.

Рациональное число представляется двумя взаимно простыми целыми числами - числителем и положительным знаменателем. Этот инвариант необходимо поддерживать при выполнении любых операций над объектами класса Rational. Публичный интерфейс класса должен включать:

Конструктор по умолчанию, который инициализирует число нулем;
Неявный конструктор преобразования от целых чисел (должен работать следующий код Rational x = 5;). Не забудьте добавить комментарий // NOLINT (см. замечания);
Конструктор от двух целых чисел (числитель и знаменатель). При этом не гарантируется, что числа взаимно простые и ненулевые (об этом далее);
Методы GetNumerator() и GetDenominator(), возвращающие числитель и знаменатель соответственно;
Методы SetNumerator(int) и SetDenominator(int), устанавливающие числитель и знаменатель в требуемые значения;
Бинарные арифметические операции (+, -, /, *) и их присваивающие версии (+=, -=, /=, *=);
Унарные операции (+, -), а также префиксные и постфиксные инкременты и декременты (++, --);
Операции сравнения;
Операции ввода из потока и вывода в поток (>>, <<< /code>);
При выводе числа в поток необходимо выводить его в виде несократимой дроби в формате <числитель>/<знаменатель> либо <числитель> , если знаменатель равен 1. Ввод осуществляется в том же формате (но дробь на входе необязательно несократима).

Пример:

Rational x = 5;        // дробь 5/1
std::cout << x;        // вывод: 5
x.SetDenominator(15);  // дробь 1/3 (5/15 сократилась)
std::cout << x;        // вывод: 1/3
std::cin >> x;         // ввод: 14/-6, дробь: -7/3 (общий множитель 2; знаменатель > 0)
Деление на 0
При делении на 0 (в операции деления или при установке знаменателя в 0) программа должна сообщать об ошибке. Для этих целей в C++ есть механизм исключений. Исключение - объект некоторого класса, который унаследован от стандартного класса ошибки библиотеки C++. Если не все ясно сейчас, то это ok, если не все понятно перед зачетом или экзаменом - у вас проблемы.

Класс ошибки RationalDivisionByZero написан за вас, вам лишь требуется в момент, когда происходит деление на ноль, сообщить об ошибке с помощью строки: throw RationalDivisionByZero{};

Замечания.

Решение должно состоять из файлов rational.h (объявления) и rational.cpp (определения). Если для решения вам требуются другие компилируемые файлы с реализацией, их стоит добавить в переменную RATIONAL_SRC в файле CMakeLists.txt.
Хорошей идеей будет вынести логику сокращения дроби в отдельный метод.
std::gcd.
Гарантируется, что числитель и знаменатель в любой момент помещаются в int32_t.
Кодстайл запрещает неявные конструкторы преобразования (и правильно делает), но в этой задаче неявное преобразование из целых чисел в рациональное вполне осмысленно. Чтобы чекер проигнорировал проверку строки с объявлением такого конструктора, добавьте комментарий // NOLINT к этой строке.
В задаче есть открытые и закрытые тесты. Перед отправкой решения проверяйте его на открытых тестах (чуда не будет, если есть ошибка в публичных тестах, то она проявится и на более сложных приватных).

B*. Matrix
Ограничение времени	1 секунда
Ограничение памяти	64.0 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
https://gitlab.com/ibr11/cpp_psami_base_2023/-/tree/main/matrix

Условие
В этом задании вам необходимо реализовать шаблонный класс для работы с матрицами фиксированного размера. Последнее означает, что размеры матрицы должны передаваться в виде шаблонных параметров-целых чисел (non-type template parameters), и для конкретного объекта не могут быть изменены в течении работы программы. С одной стороны, это накладывает ограничения - размер матриц должен быть жестко задан на этапе компиляции и пользователь не имеет возможности его менять. Кроме того, изменения параметров матриц будут требовать повторной компиляции исходного кода, использующего эти матрицы. С другой стороны, так как размеры матрицы - константы времени компиляции, мы имеем возможность использовать нединамические массивы (что заметно ускоряет работу с матрицами), компилятор имеет больше возможностей для оптимизации кода, а неправильная работа с матрицами (умножение матриц неподходящих размеров, обращение неквадратных матриц и т.п.) будет детектироваться еще на этапе сборки программы, а не во время исполнения.

Детали реализации
Требуется реализовать шаблонный класс Matrix, принимающий в качестве шаблонных параметров тип хранимых элементов, число строк матрицы и число столбцов. Так как шаблонные параметры - это константы времени компиляции, элементы матрицы можно хранить в двумерном C-style массиве (std::array в этом задании пока запрещен). Это поле-массив должно быть публичным для корректной работы агрегатной инициализации.

Для работы с матрицей предлагается реализовать следующие методы:

RowsNumber() и ColumnsNumber(), возвращающие число строк и столбцов соответственно;
Операция () ("круглые скобки") для доступа к элементам матрицы и возможности их изменения (подумайте, почему не []);
Метод At, аналогичный предыдущему пункту, но бросающий исключение MatrixOutOfRange в случае выхода за границы матрицы;
Функцию GetTransposed(matrix), возвращающую транспонированную версию переданной матрицы;
Операции сложения, вычитания умножения матриц и их присваивающие версии. Обратите внимание, что эти операции применимы не к любым парам матриц!;
Операции умножения и деления на число (слева и справа), а также их присваивающие версии;
Операции сравнения на равенство и неравенство двух матриц одинакового размера;
Операции ввода из потока и вывода в поток.
Пример:

Matrix a{{1, 2, 3}, {4, 5, 6}};
Matrix b = GetTransposed(a);
// a + b      CE
a + a;     // Ok
// a * a      CE 
a * b;     // Ok
// a *= b  // CE - в матрицу a нельзя присвоить матрицу другого размера
b *= Matrix{1, 2, 3, 4}; // Ok

std::cout << a;
1 2 3
4 5 6
Замечания.

Решение должно состоять из одного файла matrix.h
В задаче есть открытые и закрытые тесты. Перед отправкой решения проверяйте его на открытых тестах (чуда не будет, если есть ошибка в публичных тестах, то она проявится и на более сложных приватных).
Помните о константных и неконстантных методах
"Бросить исключение типа E" значит - написать строку throw E{};. В этот момент выполнение функции прекращается и, если исключение не будет обработано, программа завершится аварийно. Тестирующий код корректно обработает эту ошибку, вам этого делать не нужно.
Методы этого и дополнительного задания (ниже) необязательно реализовывать наиболее эффективным способом. В первую очередь проверяется правильность реализации.
Дополнительная часть
Для работы с квадратными матрицами есть множество методов не применимых к матрицам произвольного размера. Тем не менее так как размеры матриц известны заранее, мы можем на этапе компиляции проверять внутри них корректность размера.

Дополнительно реализуйте:

Функцию Transpose(matrix), который транспонирует исходную матрицу, изменяя ее (ясно, что транспонировать без изменения размера можно только квадратные матрицы);
Функцию Trace()
подсчет следа матрицы;
Функцию Determinant()
детерминант матрицы;
Функции GetInversed() и Inverse() для обращения матриц (первый метод возвращает обратную, а второй изменяет исходную матрицу).
При попытке обращения вырожденной матрицы необходимо бросать исключение MatrixIsDegenerateError.

Важно: если вы выполнили это задание, добавьте в файл matrix.h следующую строку, чтобы в тесты была включена проверка этого задания. c++ #define MATRIX_SQUARE_MATRIX_IMPLEMENTED

C. Компаратор для Кубка Огня
Ограничение времени	0.5 секунд
Ограничение памяти	8.0 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
До того как Гарри впервые отправился в Хогвартс, то есть в последний раз, когда он жил со своими родителями, у его отца в кабинете был компьютер. Это была Серьёзная вещь, к которой нужно относиться с Большой Ответственностью, однако Гарри провёл несколько счастливых часов, используя новейшую Windows 3.0, и даже поигрался с ещё более захватывающими командами MS-DOS, что привело к опасному и стремительному финалу.

Последний барьер, разделяющий мир маглов и магов пал — теперь волшебники тоже участвуют в ICPC. К несчастью, выяснилось, что Кубок Огня не умеет сортировать команды в таблице результатов (по крайней мере пока).

Участники упорядочиваются в рейтинге по следующим правилам:

Сначала учитывается количество решённых задач (в порядке убывания).
Далее, при равенстве количества решённых задач, Кубок учитывает штрафное время прохождения испытания (в порядке возрастания).
При прочих равных сортировка происходит по номеру команды (в порядке возрастания).
Формат ввода
Первая строка содержит натуральное число 
n
n 
(
1
≤
n
≤
1
0
5
)
(1≤n≤10 
5
 ) — количество команд, участвующих в контесте.

В 
i
i-й из следующих 
n
n строк записано количество решенных задач 
S
S 
(
0
≤
S
≤
100
)
(0≤S≤100) и штрафное время 
T
T 
(
0
≤
T
≤
1
0
5
)
(0≤T≤10 
5
 ) команды с номером 
i
i.

Формат вывода
В выходной файл выведите 
n
n чисел — номера команд в отсортированном порядке.

D. Новые факультеты
Ограничение времени	0.5 секунд
Ограничение памяти	8.0 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Честно говоря, за всю свою жизнь - которая включала эпизод, когда в обуви каждого второкурсника-слизеринца оказались трансфигурированные живые сороконожки - Фред и Джордж не слышали практически ничего, настолько же жуткого.

Резонансное расширение бакалавриата Хогвартса — школа волшебства открывает новые факультеты! Из-за экстремального количества новых структурных подразделений (по слухам количество факультетов в итоге может достигнуть 
1
0
9
10 
9
 ) каждый факультет теперь будет обозначен отдельным номером.

В дни выпускных экзаменов руководство школы решило наконец-то подсчитать сколько же студентов заканчивает каждый факультет. Для этого всех юных волшебников выстроили в ряд в порядке возрастания номеров факультетов. Все, что вам осталось — научить Распределяющую Шляпу отвечать на соответствующие запросы. За один запрос она должна узнавать количество учеников ровно для одного факультета.

Формат ввода
В первой строке входного файла содержится единственное число 
N
N 
(
0
≤
N
≤
1
0
5
)
(0≤N≤10 
5
 ) — количество студентов в Хогвартсе.

В следующей строке находятся 
N
N упорядоченных по неубыванию неотрицательных целых чисел, не превосходящих 
1
0
9
10 
9
  и разделенных пробелами — их факультеты.

В третьей строке файла записано число 
M
M 
(
1
≤
M
≤
100000
)
(1≤M≤100000) — количество запросов вашей программе, в следующей строке через пробел записаны 
M
M целых неотрицательных чисел (не превышающих 
1
0
9
+
1
10 
9
 +1).

Формат вывода
Выходной файл должен содержать 
M
M строчек. Для каждого запроса выведите число студентов для заданного факультета.

E. Пожиратели смерти и бюрократия
Ограничение времени	0.5 секунд
Ограничение памяти	8.0 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Волан-де-Морт пытается наладить среди Пожирателей Смерти строгую квартальную отчетность. К сожалению, очередной неудавшийся побег из Азкабана спутал ему все карты, поэтому кто-то не прислал отчеты вовсе, а кто-то сделал это несколько раз ("чтобы по цифрам все сходилось"). Из-за необходимости поддерживать секретность, все имена Пожирателей в итоговом списке закодированы числами.

Теперь самому ответственному из добрых людей в красивых масках требуется проверить, сколько раз какой из Пожирателей встречается в итоговом отчете.

Гермиона Грейнджер предупреждает: Старайтесь избегать циклов.

Формат ввода
В первой строке задается одно натуральное число 
N
N, не превосходящее 1,000,000 — размер отчета.

Во второй строке вводятся 
N
N чисел — элементы отчета (целые числа, не превосходящие по модулю 1,000).

В третьей строке содержится одно целое число 
x
x , не превосходящее по модулю 1,000,000.

Формат вывода
Вывести одно число — сколько раз встречается 
x
x в данном отчете.