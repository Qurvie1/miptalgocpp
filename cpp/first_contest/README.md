A. Тетрадка
Ограничение времени	1 секунда
Ограничение памяти	256Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Проектная работа Виталика по компьютерному зрению заключается в распознавании типа тетрадки по небольшому ее участку (в клетку, в линейку, в вертикальную линейку). Однако времени обучать нейросеть у Виталика нет, поэтому он попросил вас помочь ему написать программу на C++, которая бы делала это без привлечения искусственного интеллекта (почему вы согласились на это, и почему эта задача обязательна, легенда умалчивает).

Часть тетрадки представляет собой двумерную таблицу из нулей и единиц, где единица — закрашенный участок, а нуль — незакрашенный. Вертикальной линией считается столбец, в котором стоят только единицы, горизонтальной — строка, второй стоят только единицы. Гарантируется, что тетрадь изначально пустая, то есть единица обязательно является частью какой-то линии.

Тетрадь в горизонтальную линейку состоит только из горизонтальных линий, в вертикальную линейку — только из вертикальных линий, в клетку — из линий обоих типов. Причем расстояния между всеми параллельными линиями одинаковы (клетки - обязательно квадраты), и между ними обязательно есть пустоты (не могут располагаться вплотную).

По заданному участку выведите тип тетради, если его возможно однозначно определить.

Формат ввода
В первой строке даны целые числа n и m (1 ≤ n, m ≤ 1 000) — количество строк и столбцов в видимом участке. Далле следует n строк по m целых чисел ai, j (0 ≤ ai,j ≤ 1) — видимый участок тетради.

Формат вывода
В качестве ответа выведите:

«Square», если тетрадка в клетку; «Line», если тетрадка в линейку; «Vertical line», если тетрадка в вертикальную линейку; «?», если невозможно однозначно определить, к какому типу относится данная тетрадь.

B. Бинпоиск. Шаблоны
Ограничение времени	1 секунда
Ограничение памяти	256.0 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Пришлите заголовочный файл с определениями трех шаблонных функций для работы с отсортированными последовательностями. Каждая функция принимает три аргумента: 
b
e
g
i
n
begin - указатель на начало последовательности, 
e
n
d
end - указатель на конец последовательности (элемент следующий за последним), 
v
a
l
u
e
value - запрос.

BinarySearch
функция, осуществляющая проверку наличия элемента 
v
a
l
u
e
value в отсортированной последовательности 
[
b
e
g
i
n
,
e
n
d
)
[begin,end). Возвращает 
t
r
u
e
true, если и только если на полуинтервале 
[
b
e
g
i
n
,
e
n
d
)
[begin,end) имеется значение 
v
a
l
u
e
value.
LowerBound
функция, осуществляющая поиск первого элемента не меньшего (
≥
≥) 
v
a
l
u
e
value на полуинтервале 
[
b
e
g
i
n
,
e
n
d
)
[begin,end). Возвращает указатель на найденный элемент, либо 
e
n
d
end, если такого нет.
UpperBound
функция, осуществляющая поиск первого элемента строго большего (
>
>) 
v
a
l
u
e
value на полуинтервале 
[
b
e
g
i
n
,
e
n
d
)
[begin,end). Возвращает указатель на найденный элемент, либо 
e
n
d
end, если такого нет.
Важно: используйте только сравнение на меньше (
<
<) и избегайте лишних копирований элементов. То есть считайте, что элементы последовательности не копируемы и могут быть сравнены только с помощью операции 
<
<.

Пример:

int array[5]{1, 2, 3, 3, 5};

BinarySearch(array + 3, array + 4, 2); // false

LowerBound(array + 1, array + 5, 3); // указатель на 2й элемент

UpperBound(array, array + 2, 4); // указатель на 2й элемент (на [0, 2) такого элемента нет)

Пришлите на проверку заголовочный файл, содержащий ТОЛЬКО определения шаблонов. Он будет включен в cpp файл с тестами автоматически (main писать не нужно!).

Формат ввода
Данная информация нужна только для понимания примера. Обработку пользовательского ввода писать не нужно. Вместо указателей в примере вводятся и выводятся индексы элементов.

На первой строчке подается число элементов в последовательности, а далее сами элементы.

В следующих строках следует число запросов и сами запросы в формате (begin, end, value).

Формат вывода
Данная информация нужна только для понимания примера. Ваши функции ничего выводить не должны.

Выводятся 3 числа - результаты вызова BinarySearch, LowerBound и UpperBound соответственно.

C. Сортировка. Шаблоны
Ограничение времени	1 секунда
Ограничение памяти	256.0 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
В данной задаче вам необходимо реализовать шаблонную функцию Sort, сортирующую переданную последовательность. Функция должна принимать два аргумента: begin - указатель на начало последовательности, end - указатель на конец последовательности (элемент следующий за последним).

Пример:

int array[5]{3, 5, 1, 4, 2};

Sort(array + 1, array + 4); // array = {3, 1, 4, 5, 2}

Ваш код будет проверяться на скрытых от вас юнит-тестах, проверяющих корректность шаблонной реализации. Требование к реализации: из операций сравнения можно использовать только операцию "<".< /p>

Пришлите на проверку заголовочный файл, содержащий ТОЛЬКО определение шаблона. Он будет включен в cpp файл с тестами автоматически (main писать не нужно!).

Формат ввода
На вход подается массив размера 
n
≤
1
0
5
n≤10 
5
 .

D. CString
Ограничение времени	0.1 секунд
Ограничение памяти	8.0 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
C-style строкой называется последовательность байт (char), ограниченная нулевым символом ('\0'). Работа с C-style строками во многом похожа на работу с массивами, при этом специфичные для строк операции (вычисление длины, конкатенация, сравнение и т.п.) вынесены в отдельную библиотеку функций <cstring>. В этом задании вам предстоит познакомиться с ней подробнее, реализовав собственный аналог.

Условие задачи
Реализуйте модуль cstring, состоящий из следующих функций:

size_t Strlen(const char* str);. Вычисляет длину строки str (без учета нулевого символа).
int Strcmp(const char* first, const char* second);. Лексикографически сравнивает две строки. Если first < second, то возвращает произвольное отрицательное число, если first > second, то - положительное. В случае равенства возвращает 0.
int Strncmp(const char* first, const char* second, size_t count);. То же, что и предыдущая функция, но сравнивает первые count символов строк (либо пока не встретит нулевой символ).
char* Strcpy(char* dest, const char* src);. Принимает строку src и копирует ее содержимое (вместе с нуль-терминатором) в dest. Гарантируется, что dest указывает на область памяти, достаточную для хранения src. Возвращает dest. Замечание: формально, std::strcpy дополнительно требует, чтобы последовательности dest и src не перекрывались (то есть длина строки src должна быть больше расстояния между указателями), так как порядок копирования символов не определен. В этом задании допускается более слабое предположение: dest не указывает внутрь строки src.
char* Strncpy(char* dest, const char* src, size_t count);. То же, что и предыдущая функция, но копирует ровно count символов из src. Если count больше размера src, то оставшиеся символы заполняются нуль-символами. Возвращает dest.
char* Strcat(char* dest, const char* src);. Приписывает строку src в конец строки dest (конкатенация строк). Гарантируется, что dest указывает на область памяти, достаточную для хранения итоговой строки. Возвращает dest.
char* Strncat(char* dest, const char* src, size_t count);. То же, что и предыдущая функция, но добавляет только первые count символов из src + нулевой символ. Если count больше чем длина src, то работает так же как и Strcat(dest, src). Возвращает dest.
const char* Strchr(const char* str, char symbol);. Возвращает указатель на первое появление символа symbol в строке str (с учетом нулевого символа), либо нулевой указатель, если такого символа нет.
const char* Strrchr(const char* str, char symbol);. Возвращает указатель на последнее появление символа symbol в строке str (с учетом нулевого символа), либо нулевой указатель, если такого символа нет.
size_t Strspn(const char* dest, const char* src);. Возвращает количество первых символов dest, которые встречаются в строке src (без учета нулевого символа).
size_t Strcspn(const char* dest, const char* src);. Возвращает количество первых символов dest, которые не встречаются в строке src (без учета нулевого символа).
const char* Strpbrk(const char* dest, const char* breakset);. Возвращает указатель на первый элемент dest, который лежит в breakset, либо нулевой указатель, если такого элемента нет.
const char* Strstr(const char* str, const char* pattern);. Осуществляет поиск подстроки pattern в строке str. Возвращает указатель на начало первого вхождения, либо нулевой указатель, если вхождения найдено не было.
При необходимости подробнее про работу функций можете прочитать на странице https://cplusplus.com/reference/cstring/ . Использовать функции memcpy, memcmp и подобные запрещено.

В качестве решения от вас ожидается модуль, состоящий из 2х файлов: cstring.h и cstring.cpp. Файлы присылайте в виде ZIP-архива.

Присланный модуль будет собран вместе с файлом с тестами на сервере, main присылать не нужно. Интерфейс функций должен в точности совпадать с тем, что описан в условии (тесты ожидают именно его), в противном случае вы получите ошибку компиляции.

При ошибке в реализации вы получите вердикт CE. В нем будет указана функция, которая требует исправлений.

E. Мирные ферзи
Ограничение времени	1 секунда
Ограничение памяти	256Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Дано число N. Определите, сколькими способами можно расставить на доске N × N N ферзей, не бьющих друг друга.

Формат ввода
Задано единственное число N, N ≤ 10.

Формат вывода
Необходимо вывести количество способов, которыми можно расставить на доске N × N N ферзей, не бьющих друг друга.

F. Лень - двигатель прогресса
Ограничение времени	1 секунда
Ограничение памяти	256Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Виталик заметил, что сдача задач по алгоритмам в свою очередь сводится к другому алгоритму, состоящему из небольшого количества уникальных действий (открытие файла, сборка, тестирование, и т.д.). Всего он выявил 26 таких действий и обозначил каждое из них строчной буквой латинского алфавита (вот совпадение!).
Для оптимизации времени, потраченного на сдачу заданий, Виталик решил написать программу (скрипт), который бы автоматизировал некоторую часть этой рутинной работы. Идея довольно проста: скрипт в цикле выполняет 
K
 фиксированных действий подряд, то есть сначала выполняется первое действие, затем второе и т.д. после окончания последнего действия работа скрипта продолжается с первого. При этом скрипт останавливается после фиксированного числа шагов (которое указывает Виталик). Время затраченное на написание скрипта Виталик считает оправданным, если он выполнит хотя бы 
K
+
1
 действие. Скрипт может запускаться только один раз.
По заданной последовательности действий определите количество способов написать "оправданный"скрипт.

Формат ввода
В первой строке записано число 
K
 > 0 — количество действий, которые выполняются в цикле скрипта. Во второй строке записаны 
N
 (
K
<
N
≤
1
0
6
) строчных латинских букв, обозначающих алгоритм сдачи задания.
Формат вывода
Выведите ответ на задачу

G. Слияние. Шаблоны
Ограничение времени	1 секунда
Ограничение памяти	66.9 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Реализуйте шаблонную функцию Merge, которая принимает две отсортированные последовательности и сливает их одну большую отсортированную.

Функция должна принимать 5 аргументов: first_begin, first_end - указатели на начало и конец первой последовательности; second_begin, second_end - начало и конец второй последовательности; out - указатель на начало итоговой последовательности (куда записывать ответ).

Последовательности first, second и out могут хранить значения разных типов!

Пример:

int16_t first[2]{1, 4};

int32_t second[3]{2, 3, 5};

int64_t out[5];

Merge(first, first + 2, second, second + 3, out); // out = {1, 2, 3, 4, 5}

Ваш код будет проверяться на скрытых от вас юнит-тестах, проверяющих корректность шаблонной реализации. Требование к реализации: из операций сравнения можно использовать только операцию "<".< /p>

Пришлите на проверку заголовочный файл, содержащий ТОЛЬКО определение шаблона. Он будет включен в cpp файл с тестами автоматически (main писать не нужно!).

H. k-я порядковая статистика. Шаблоны
Ограничение времени	1 секунда
Ограничение памяти	256.0 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Реализуйте шаблонную функцию KthElement, которая упорядочивает элементы последовательности так, чтобы на 
k
k-м месте (в 0 индексации) стоял 
k
k-й по величине элемент последовательности.

Функция должна принимать 3 аргумента: begin - указатель на начало последовательности; kth - указатель на 
k
k-ю позицию; end - указатель на конец последовательности.

Среднее время работы алгоритма должно быть линейным от длины полуинтервала *[begin, end)*.

Пример:

int array[5]{2, 3, 5, 4, 1}

KthElement(array, array + 2, array + 5); // array = {1, 2, 3, 5, 4}

Ваш код будет проверяться на скрытых от вас юнит-тестах, проверяющих корректность шаблонной реализации. Требование к реализации: из операций сравнения можно использовать только операцию "<".< /p>

Пришлите на проверку заголовочный файл, содержащий ТОЛЬКО определение шаблона. Он будет включен в cpp файл с тестами автоматически (main писать не нужно!).

I. Приоритетная очередь. Шаблоны
Ограничение времени	0.5 секунд
Ограничение памяти	64.8 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
В данной задаче вам необходимо реализовать шаблонные функции для работы с бинарной пирамидой (с максимумом на вершине):

PushHeap - восстанавливает пирамиду после добавления нового элемента (Insert);

PopHeap - восстанавливает пирамиду после извлечения максимального элемента из пирамиды.

Функция PushHeap должна принимать два аргумента: begin - указатель на начало последовательности, end - указатель на конец последовательности (элемент следующий за последним). Поведение, ожидающееся от функции: вставляет в пирамиду элемент, находящийся на позиции end-1, восстанавливает пирамиду на диапазоне [begin, end). Гарантируется, что перед выполнением функции PushHeap диапазон [begin, end - 1) является корректной пирамидой.

Функция PopHeap должна принимать два аргумента: begin - указатель на начало последовательности, end - указатель на конец последовательности (элемент следующий за последним). Поведение, ожидающееся от функции: меняет местами элемент на позиции begin с элементом на позиции end - 1 и восстанавливает пирамиду на диапазоне [begin, end-1). Гарантируется, что перед выполнением функции PopHeap диапазон [begin, end) является корректной пирамидой.

Пример:

int heap[7]{9, 5, 4, 1, 2, 3, 6}; (последний элемент не вставлен)*

PushHeap(heap, heap + 7); // heap == {9, 5, 6, 1, 2, 3, 4} (вставили 6)

PopHeap(heap, heap + 7); // heap == {6, 5, 4, 1, 2, 3, 9} (извлекли 9)

Ваш код будет проверяться на скрытых от вас юнит-тестах, проверяющих корректность шаблонной реализации. Требование к реализации: из операций сравнения можно использовать только операцию "<".< /p>

Пришлите на проверку заголовочный файл, содержащий ТОЛЬКО определение шаблона. Он будет включен в cpp файл с тестами автоматически (main писать не нужно!).

J. Простая задачка
Ограничение времени	1 секунда
Ограничение памяти	256Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Сколько времени?
Мы хотели сделать простую задачу, с которой бы все справились, но тесты немного повредились, поэтому у некоторых цифр пропали части изображения, а на некоторых появились артефакты:(

Формат ввода
На вход подаются 6 строк длины 20. Входные данные содержат 6 строк по 20 символов. Каждый прямоугольник 6x5 задает цифру циферблата.
Формат вывода
Выведите время в формате hh:mm. Если время нельзя определить однозначно, выведите AMBIGUITY. Если же в часах точно сломалось еще что-то, например, неправильный формат времени, либо отображаются лишние пиксели, выведите ERROR.

K. Пиксель-арт
Ограничение времени	1 секунда
Ограничение памяти	256Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Дана таблица размера 
N
×
M
, каждая клетка которой раскрашена в один из 
K
 цветов. Цвета пронумерованы числами от 0 до 
K
−
1
. Клетка, стоящая в 
i
-й строке и 
j
-м столбце имеет цвет 
(
i
+
j
)
%
K
. Строки и столбцы нумеруются с 0.
Для каждого цвета укажите, сколько раз он встречается в таблице.

Формат ввода
Вводятся числа 
N
, 
M
, 
K
 (
1
≤
N
,
M
≤
1
0
9
, 
1
≤
K
≤
2
⋅
1
0
5
) — размеры таблицы и количество цветов соответственно.
Формат вывода
Выведите через пробел 
K
 целых чисел, где 
i
-е число обозначает количество клеток, покрашенных в 
i
-й цвет (
i
 от 0 до 
K
−
1
).

L. Матрица
Ограничение времени	1 секунда
Ограничение памяти	256.0 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Дан набор натуральных чисел: 
a
1
a 
1
​
 , …, 
a
N
a 
N
​
 . По этому набору строится таблица чисел размером N x N по следующему правилу: в клетку i-го столбца j-й строки записывается большее из чисел 
a
i
a 
i
​
  и 
a
j
a 
j
​
  при 
i
≠
j
i

=j (если 
a
i
=
a
j
a 
i
​
 =a 
j
​
 , то записывается это число); на пересечении i-го столбца и i-й строки записывается число 0.

Дана таблица чисел. Требуется определить, могла ли она быть построена по данным правилам из какого-либо набора чисел 
a
1
a 
1
​
 , …, 
a
N
a 
N
​
 .

Формат ввода
В первой строке входных данных задается натуральное число 
N
N -- размер таблицы (
1
≤
N
≤
500
1≤N≤500). В следующих 
N
N строках содержится по 
N
N чисел -- числа соответствующей строки из таблицы (все числа целые неотрицательные и не превосходят 1 000).

Формат вывода
В одну строку выведите через пробел числа 
a
1
a 
1
​
 , …, 
a
N
a 
N
​
 . Если решений несколько, выведите любое из них. Если набора, удовлетворяющего данной таблице, не существует, выведите одно число "-1".