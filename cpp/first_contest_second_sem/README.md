A*. String
Ограничение времени	30 секунд
Ограничение памяти	64.0 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
В качестве решения ожидается zip архив с решением (даже если решение состоит из одного файла). Присылайте файлы только с ВАШИМ кодом, то есть файлы с тестами и CMakeLists.txt присылать не нужно.

Условие
Напишем класс динамической саморасширяющейся строки, заодно познакомимся со стандартным классом std::string.

std::string
Класс std::string предоставляет удобный и безопасный интерфейс работы со строками в C++. Одна из главных проблем стековых и выделяемых в куче строк (массивов char) заключается в том, что они имеют фиксированный размер и не умеют автоматически расширяться при необходимости. При создании строк в динамической области возникает потребность в ручном отслеживании возможных утечек памяти, что накладывает дополнительные сложности на процесс разработки. Кроме того, C-style строки не хранят информацию о своем размере, что тоже не упрощает взаимодействие с ними.

Эти проблемы можно обойти, используя ООП функционал C++. В частности, механизм инкапсуляции позволяет хранить размер строки в отдельном поле, реализовать методы, при вызове которых массив будет автоматически расширяться, создавая иллюзию неограниченной строки, а механизмы работы с ресурсами гарантируют своевременное выделение и очищение памяти.

Пример:

std::string s = "hello";
s.Size();        // 5, работает за O(1)
s[0] = 'H';
s += ", world!"  // строка расширяется
std::cout << s;  // "Hello, world!"
Подробнее о возможностях std::string здесь.

Задание
Реализуйте класс динамической строки - аналог std::string, с эффективной стратегией расширения (мультипликативная схема).

Введем понятия "размера" строки (size) и ее "вместимости" (capacity). С++ в каждый момент времени позволяет поддерживать массивы конечной вместимости (сколько выделено памяти), при этом фактический размер (количество реально используемых символов) может быть меньше этого значения. Почему бы постоянно не поддерживать равенство между этими величинами? - Это не эффективно. Допустим, мы добавляем символы в конец строки по одному. Тогда при каждом обновлении будет происходить перевыделение исходной памяти с последующим копированием всех старых элементов в новый буфер. Легко видеть, что в этом случае общее число копирований будет квадратичным образом зависеть от числа добавленных элементов. Оказывается, что, если при каждом переполнении массива увеличивать его вместимость в константное число раз, то можно добиться линейной зависимости числа операций над массивом от числа добавляемых элементов. В вашем решении будет проверяться корректность работы данной схемы при множителе равном 2 (то есть, при переполнении буфера его вместимость должна увеличиваться минимум в 2 раза).

Детали реализации
Реализуйте класс String со следующим интерфейсом:

Конструктор по умолчанию - создает пустую строку (nullptr);
Конструктор, принимающий size и symbol, - создает строку длины size, заполненную символами symbol.
Конструктор, принимающий С-style строку (const char*) и создающий на ее основе строку. Этот конструктор должен уметь выполнять неявные преобразования, поэтому не нужно объявлять его explicit. Это не понравится кодстайл чекеру, поэтому к строке с объявлением добавьте комментарий // NOLINT, чтобы он проигнорировал эту строку.
Конструктор, принимающий массив char (const char*) и количество первых символов (size), которые нужно скопировать.
Правило "трех".
Константный и неконстантный оператор доступа по индексу []. Последний должен позволять изменять полученный символ (s[0] = 'H');
Константный и неконстантный метод доступа по индексу At. При выходе за границы строки должен бросать исключение StringOutOfRange, которое написано за вас (об этом ниже).
Методы Front() и Back()
доступ к первому и последнему символам (тоже по две версии).
Методы CStr() и Data()
возвращают указатель на начало строки (C-style строку).
Метод Empty()
true, если строка пуста (размер 0).
Методы Size() и Length()
размер строки.
Метод Capacity()
текущая вместимость.
Метод Clear()
устанавливает размер в 0, удаления выделенной памяти при этом НЕ происходит.
Метод Swap(other)
обменивает содержимое с другой строкой other.
Метод PopBack()
удаляет последний символ.
Метод PushBack(symbol)
добавляет символ symbol в конец строки (при необходимости строка расширяется).
Операция +=
принимает другую строку (String) и приписывает ее в конец текущей.
Метод Resize(new_size, symbol)
изменяет размер на new_size. Если вместимость не позволяет хранить столько символов, то выделяется новый буфер с вместимостью new_size. В случае new_size > size заполняет недостающие символы значением symbol.
Метод Reserve(new_capacity)
изменяет вместимость на max(new_capacity, текущая вместимость). Размер при этом не изменяется.
Метод ShrinkToFit()
уменьшает capacity до size (убирает излишек).
Конкатенация с помощью операции +.
Операции сравнения (<, >, <=, >=, ==, !=), задающие лексикографический порядок.
Операция вывода в поток.
Замечания.

Решение должно состоять из файлов cppstring.h и cppstring.cpp.
В этой задаче запрещается использование стандартной библиотеки C++. Если нужны какие-либо служебные классы или функции, реализуйте их самостоятельно.
Проверка устроена таким образом, что требует от вас жесткого следования принятым (выше) сигнатурам и именованиям сущностей (то есть никакие MyString, __string_, push_back, superSolver3000 не пройдут). Если вы реализовали требуемый функционал не полностью или интерфейс отличается от заявленного, вы получите ошибку компиляции.
В тесты включены проверки функциональности (методы работают так как требует условие), проверка эффективности реализации (что значит эффективно описано выше), проверка корректности работы с памятью (утечки памяти, обращения к памяти не принадлежащей процессу будут приводить к провалу).
"Бросить исключение типа E" значит - написать строку throw E{};. В этот момент выполнение функции прекращается и, если исключение не будет обработано, программа завершится аварийно. Тестирующий код корректно обработает эту ошибку, вам этого делать не нужно.

B*. UniquePtr
Ограничение времени	1 секунда
Ограничение памяти	64.0 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Условие
С++ предоставляет шаблонный класс std::unique_ptr (https://en.cppreference.com/w/cpp/memory/unique_ptr) для безопасной работы с динамически выделенной памятью (и другими ресурсами). В std::unique_ptr перегружены все необходимые операции для комфортной работы с объектами так, как если бы это были обычные указатели (которые еще память за собой очищают). Объекты этого класса считаются единственными владельцами ресурса, на который они указывают, поэтому эти объекты нельзя копировать, но можно перемещать - передавать владение другому объекту. Использование std::unique_ptr почти не накладывает дополнительных вычислительных расходов, поэтому пользоваться им так же эффективно, как и обычными указателями, и при этом гораздо безопаснее.

Пример:

#include <memory>

// ...

std::unique_ptr<int> ptr(new int(10));

std::cout << *ptr << '\n';  // 10

// std::unique_ptr<int> copy = ptr; копирование запрещено

std::unique_ptr<int> moved = std::move(ptr);  // теперь ptr пуст

std::cout << *moved << '\n';  // 10

auto rational = std::make_unique<Rational>(1, 2);

// эквивалентно std::unique_ptr<Rational> rational(new Rational(1, 2));

std::cout << rational->Numerator() << ' ' << rational->Denominator() << '\n';  // 1 2

// delete вызовутся автоматически в деструкторах!
Задание
Реализуйте шаблон UniquePtr - упрощенный аналог класса умного указателя с уникальным владением, std::unique_ptr (C++11).

Детали реализации
Шаблонный класс должен поддерживать:

Конструктор по умолчанию (создает нулевой указатель).
Конструктор от указателя (сохраняет указатель на объект).
Конструктор копирования и копирующее присваивание должны отсутствовать.
Перемещающий конструктор и перемещающее присваивание должны передавать владение объектом.
Метод Release(), который отлучает класс от владения текущим ресурсом и возвращает указатель на него.
Метод Reset(T* ptr = nullptr), меняет указатель, которым владеет объект (старый ресурс удаляется).
Метод Swap(UniquePtr&).
Метод Get(), возвращающий указатель на объект.
Оператор разыменовывания operator*.
Оператор "стрелочка" operator->.
Явный оператор приведения к bool (operator bool).
Замечания.
https://en.cppreference.com/w/cpp/memory/unique_ptr
Решение должно состоять из одного файла unique_ptr.h

C*. SharedPtr
Ограничение времени	1 секунда
Ограничение памяти	64.0 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt

Умные указатели реализуют важную идиому C++ - RAII (Resource Acquisition Is Initialization) и позволяют не заботиться о ручном управлении памятью, так как инкапсулируют управление ресурсами посредством конструкторов и деструкторов.

std::shared_ptr (C++11)
Шаблонный класс std::shared_ptr предоставляет интерфейс указателя на данные в динамической области с автоматическим контролем своевременного выделения и удаления ресурсов. В отличие от std::unique_ptr, std::shared_ptr реализует семантику разделяемого владения ресурсом, что означает, что у одного ресурса может быть несколько равноправных владельцев. При этом гарантируется, что ресурс не будет освобожден пока существует хотя бы один его владелец (хотя бы один объект std::shared_ptr указывает на ресурс). Для решения проблемы циклических ссылок в язык также введены "слабые указатели" std::weak_ptr, которые не считаются полноценными владельцами ресурса, но из них при необходимости можно получить "сильный указатель" std::shared_ptr на объект, если тот еще не удален.

Несмотря на то, что std::shared_ptr удобнее в использовании чем std::unique_ptr, на практике последний работает гораздо эффективней - std::shared_ptr реализует дополнительную логику с подсчетом ссылок на объект. Поэтому std::shared_ptr стоит использовать только тогда, когда вам действительно нужно разделяемое владение.

Задание
Реализуйте шаблон SharedPtr - упрощенный аналог класса умного указателя с разделяемым владением.

Идея реализации: помимо самого указателя на выделенный ресурс необходимо знать число "сильных" и "слабых" ссылок на объект. Для этого в куче выделим специальную счетчик strong_counter, который будет хранить эту информацию (при создании нового указателя соответствующий счетчик увеличивается, при удалении - уменьшается; если число сильных ссылок стало равно 0, то объект удаляется).

Детали реализации
Детали обсуждались на лекции и семинарах. Шаблонный класс SharedPtr должен поддерживать:

Конструктор по умолчанию (создает нулевой указатель).
Конструктор от указателя (сохраняет указатель на владеемый объект).
Конструктор копирования и копирующее присваивание (создают новую ссылку на тот же объект).
Перемещающий конструктор и перемещающее присваивание должны передавать владение объектом.
Метод Reset(T* ptr = nullptr), меняет указатель, которым владеет объект.
Метод Swap(SharedPtr&).
Метод Get(), возвращающий указатель на владеемый объект.
Метод UseCount(), возвращающий число "сильных" ссылок на объект.
Оператор разыменовывания operator*.
Оператор "стрелочка" operator->.
Явный оператор приведения к bool (operator bool).
Замечания.
https://en.cppreference.com/w/cpp/memory/shared_ptr
Решение должно состоять из одного файла shared_ptr.h
Дополнительное задание
Реализуйте шаблон WeakPtr - аналог std::weak_ptr. Для поддержки "слабых" ссылок (см. выше) предлагается вынести счетчик обычных (сильных) ссылок strong_count в отдельную структуру Counter, в которую дополнительно добавить поле weak_count для подсчета количества слабых указателей, указывающих на данный объект. Как и ранее, сам счетчик (объект Counter) должен находиться в динамической памяти (вспомните почему), а указатель на него храниться в соответствующих объектах SharedPtr и WeakPtr. Логика освобождения ресурса теперь следующая:

Если число сильных и слабых ссылок стало равно нулю, то удаляется и объект, и выделенный для него счетчик Counter.

Если число сильных стало равно нулю при ненулевом числе слабых, то удаляется только объект, счетчик остается жить (то есть все сильные указатели уже "умерли", а некоторые слабые все еще ссылаются на данный счетчик).

Шаблон WeakPtr состоит из:

Аналогичных конструкторов (по умолчанию, копирования, перемещения) и операторов присваивания.

Конструктора от SharedPtr (увеличивает число "слабых" ссылок)

Метода Swap(WeakPtr&)

Метода Reset(), отвязывающего указатель от объекта

Метода UseCount(), возвращающего число "сильных" ссылок на объект

Метод Expired(), возвращающий true, если сильных ссылок на объект уже нет (объект удален)

Метод Lock(), возвращающий SharedPtr на объект (если Expired() == true, то возвращается пустой указатель)

В SharedPtr необходимо добавить конструктор от WeakPtr, который работает аналогично методу Lock(), но в случае Expired() == true должно бросаться исключение BadWeakPtr.

Замечания.
https://en.cppreference.com/w/cpp/memory/weak_ptr
Для проверки этой части добавьте в файл с решением (shared_ptr.h) директиву
#define WEAK_PTR_IMPLEMENTED

E. Any
Ограничение времени	1 секунда
Ограничение памяти	64.0 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt

В этом задании необходимо реализовать упрощенный аналог класса std::any с помощью механизма "type erasure" (стирание типов).

std::any (C++17)
В C++17 появился класс, позволяющий хранить в себе объекты произвольных типов. Ровно как в динамически типизированных языках, типа Python, одна и та же переменная может использоваться для хранения разных типов (a = "aba"; a = 3; - валидный код), при этом формально, конечно, ее тип всегда будет оставаться std::any.

Пример:

std::any a = std::string("aba");  // сейчас a содержит строку "aba"

a = true;  // а теперь булевское значение true

std::any b;  // "пустой" объект
Но C++ - статически типизированный язык, поэтому "за удовольствие приходится платить". Во-первых, дополнительными накладными расходами, а, во-вторых, удобством использования. Например, нельзя просто так взять и присвоить значение std::any другой переменной, даже если тип ее текущего значения совпадает с типом принимающей стороны (подумайте, почему, в чем сложность реализации такого механизма?). Для получения значения конкретного типа необходимо явно попросить об этом с помощью шаблонной функции std::any_cast<T>, где T - требуемый тип. В случае, если в данный момент объект содержит не тип T, бросается исключение std::bad_any_cast.

Пример:

std::any a = std::string("aba");  // сейчас a содержит строку "aba"
    
auto str = std::any_cast<std::string>(a);  // корректно получено текущее значение   
 
auto x = std::any_cast<int>(a);  // выбросится исключение, так как a содержит не int
Полезные методы:

reset()
обнуляет объект, делая его пустым;
swap(std::any&)
обменивает содержимое;
has_value()
true, если объект не пуст, false иначе;
Внешняя шаблонная функция std::make_any<T>(args...)
принимает аргументы конструктора, с которым нужно создать объект типа T и возвращает std::any с этим объектом.
Подробнее в справочнике.

Type erasure
Возникает естественный вопрос, как реализовать подобный механизм? Что нужно хранить в полях класса, чтобы иметь возможность сохранять объекты любых типов и в нужный момент понимать, что за тип хранится в нем?

Относительно простое решение - хранить указатель void* на динамическую память. При присваивании выделять в куче память под новый объект, освобождать при изменении типа объекта. Значение типа получать, например, с помощью оператора typeid. Но здесь возникают серьезные вопросы по безопасности работы с "сырой" памятью и приведением типов между указателями.

В этом задании мы предлагаем познакомиться с более изящной техникой "стирания типов" (type erasure). Окей, мы не можем хранить в поле класса произвольный тип, он должен быть фиксирован для всех объектов. Что бы нам такое сохранить, чтобы тип был фиксирован, но фактически под ним могло лежать значение другого типа? Стоп, но это же ровно то, что достигается при помощи динамического полиморфизма (указатель на полиморфный базовый класс может указывать на любого из наследников). Таким образом, если создать полиморфный базовый класс Base, от которого затем унаследовать всевозможные типы (что?!), то можно будет хранить в поле указатель на базу. Но как унаследовать, например, int или std::string от Base? Спойлер: никак. Но можно написать специальные классы-обертки над типами: DerivedInt, DerivedString, DerivedBool... и наследовать их... Стоп. C++ же нам позволяет автоматически генерировать классы параметризованные произвольными типами, используя механизм шаблонов! Достаточно написать реализацию для Derived<T> и нужные версии будут создаваться автоматически по мере необходимости!

Детали реализации
Для решения вам понадобится написать пустой (без полей) абстрактный базовый класс IHolder (Base) и шаблонный класс AnyHolder<T> (Derived) -- наследник IHolder, который будет хранить в себе единственное поле типа T - требуемое значение. В свою очередь, AnyHolder должен поддерживать конструктор от T, чтобы инициализировать поле (будем считать, что у T есть конструктор копирования и/или move конструктор).

Основной класс Any должен иметь:

Поле-указатель (умный) на IHolder.
Конструктор по умолчанию, выставляющий указатель в nullptr (пустой объект)
Конструктор копирования. Для удобства реализации, заведите в IHolder чисто виртуальный метод Clone(), который возвращает указатель на новый выделенный объект. Естественно, нужно будет написать его реализацию в AnyHolder. Все копирование в итоге должно свестись к одному вызову Clone().
Шаблонный конструктор от объекта произвольного типа T (который должен хранить объект Any). Здесь нужно создать в куче объект AnyHolder<T> и присвоить его адрес полю-указателю на IHolder. (Обращаем внимание, что здесь-то и произошло "стирание типа")
Аналогичный оператор присваивания.
Методы Swap(Any& other), Reset() и HasValue() (описания даны выше).
Также реализуйте класс исключения BadAnyCast, и внешнюю шаблонную функцию template <class T> T any_cast(const Any& value), которая возвращает значение, в случае, если IHolder указывает на AnyHolder<T> и бросает BadAnyCast в противном случае (вам наверняка пригодится dynamic_cast).

Замечания.

Класс активно работает с кучей и механизмом позднего связывания, что может существенно влиять на производительность, поэтому его стоит использовать с осторожностью.
Решение должно состоять из одного файла any.h.

F. Calculator.Tokenize
Ограничение времени	1 секунда
Ограничение памяти	64.0 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Когда говорят "компьютерная программа", одно из первых, что приходит на ум, - калькулятор. Действительно, изначальное назначение компьютеров - производить математические вычисления. И кажется, это настолько базовая задача, что написать калькулятор на любом известном вам языке программирования не составляет никакого труда. Тем не менее оказывается, что это не такая уж тривиальная и скучная задача. Как, например, вычислить значение, заданное входом "1 * (((2 * 3) * (4 + 5) + 6 + 7) * (8 * 9 + 10 * 11) * 12)"? Данная задача в трех частях ответит на этот вопрос.

Tokenize
Первым шагом практически в любой задаче, работающей с пользовательским вводом, является токенизация - разбиение исходного текста на отдельные смысловые части (например, фразы, слова, буквы). В нашей задаче в качестве токенов будут выступать математические символы.

Всего рассмотрим 13 типов токенов: "+" (PlusToken), "-" (MinusToken), "*" (MultiplyToken), "/" (DivideToken), "%" (ResidualToken), "(" (OpeningBracketToken), ")" (ClosingBracketToken), "sqr" (SqrToken), "max" (MaxToken), "min" (MinToken), "abs" (AbsToken), "23" (NumberToken, здесь произвольное число), "abracadabra" (UnknownToken).

Для каждого типа токена необходимо завести свою структуру (название написано в скобках). Все структуры могут быть пустыми, за исключением NumberToken, который дополнительно в int поле value должен хранить значение числа, и UnknownToken, который в строковом поле value должен хранить значение неизвестного токена.

Чтобы хранить все токены в одном контейнере необходимо привести все значения к одному типу. Мы бы могли вновь воспользоваться наследованием и хранить указатель на базовый класс, но в этом задании мы познакомимся с классом std::variant (C++17), который может хранить в себе значение одного из заранее заданных типов (ООП аналог union).

std::variant (C++17)
https://en.cppreference.com/w/cpp/utility/variant

std::variant - шаблонный класс, который может хранить в себе произвольное значение одного из нескольких указанных в шаблоне типов. Основные функции, которые вам понадобятся:

std::get<T> принимает тип T в качестве параметра шаблона и объект std::variant в качестве аргумента. Если тип хранимого в данный момент объекта совпадает с указанным, то возвращается значение, иначе бросается исключение std::bad_variant_access;
std::holds_alternative<T> проверяет лежит ли в данный момент в объекте значение типа T и возвращает true или false в зависимости от результата;
operator== возвращает true, если для хранимых объектов совпадают типы и их значения.
Остальные методы и функции можете найти в документации.

Пример:


std::variant<int, std::string> v;  // объект может хранить в себе либо int, либо std::string

v = 5;  // сейчас в нем хранится int

if (std::holds_alternative<int>(v)) std::cout << std::get<int>(v);  // на экране "5"

v = std::string("aba");  // теперь хранится std::string

std::get<int>(v);  // бросается исключение (хранится не int)

v = std::array<int, 3>();  // ошибка компиляции (v не может хранить std::array<int, 3>)
Детали реализации
В файле tokenize.h объявите и определите описанные выше структуры и заведите тип Token, который может хранить любой тип токена, как псевдоним std::variant<PlusToken, MinusToken,... (и т.д.)> (с помощью using). Не забудьте определить оператор сравнения на равенство для каждого типа токена, чтобы сравнение двух токенов в тестах работало нормально (для токенов, которые ничего не хранят, сравнение на == должно просто возвращать true).

Основное задание заключается в написании функции std::vector<Token> Tokenize(std::string_view), которая принимает строку и возвращает последовательность токенов в ней.

Опишите прототип в файле tokenize.h, а реализацию и необходимые побочные функции в tokenize.cpp.

Для простоты будем считать, что все токены разделены произвольным ненулевым количеством пробелов.

G. Calculator.PolishNotation
Ограничение времени	1 секунда
Ограничение памяти	64.0 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Когда говорят "компьютерная программа", одно из первых, что приходит на ум, — калькулятор. Действительно, изначальное назначение компьютеров - производить математические вычисления. И кажется, это настолько базовая задача, что написать калькулятор на любом известном вам языке программирования не составляет никакого труда. Тем не менее оказывается, что это не такая уж тривиальная и скучная задача. Как, например, вычислить значение, заданное входом "1 * (((2 * 3) * (4 + 5) + 6 + 7) * (8 * 9 + 10 * 11) * 12)"? Данная задача в трех частях ответит на этот вопрос.

Polish Notation
Трудоемкость написания калькулятора заключается в сложности определения порядка выполняемых действий и построения дерева разбора выражения. Дерево разбора выражения - корневое дерево, вершинами которого являются операции, а дети вершин - выражения (поддеревья), являющиеся их операндами. В листьях дерева находятся числа (константы).

Выражения записанные в польской нотации очень просты для разбора, так как операции в ней уже записаны в нужном для вычисления порядке (в порядке pre-order обхода дерева).

Пример:

"+ 3 4": читаем оператор + -> он бинарный -> читаем первый и второй операнд, 3 и 4 -> получаем результат операции 7
  +
 / \
3   4

"+ 3 * 4 5": извлекаем оператор + -> он бинарный -> вычисляем первый операнд - 3
-> второй операнд - результат операции * -> вычисляем его операнды (аналогично первому примеру)
-> вычисляем результат выражения
  +
 / \
3   *
   / \
  4   5
Формально, каждое значение (токен) в польском выражении можно считать некоторой операцией. Пусть дан массив токенов и в данный момент рассматриваем токен в позиции pos. Построение дерева разбора в общем случае выглядит так:

Определяется тип операции и ее арность (количество операндов). Сдвигаем pos на 1 элемент вправо.
Если операция не требует аргументов (константа), то возвращаем ее в качестве результата.
Если операция унарная, рекурсивно строим поддерево для операнда, сохраняем его в соответствующее поле операции, возвращаем операцию (корень поддерева).
Если операция бинарная, рекурсивно строим поддерево первого аргумента, второго аргумента, сохраняем их в поля объекта нужной бинарной операции, возвращаем этот объект в качестве ответа (корня поддерева).
Например, возведение в квадрат - унарная операция: она извлекается; далее строится операнд посредством обработки следующей операции в массиве; мы знаем, что результат обработки - это операция, результат которой будет выступать аргументом; сохраняем ее в поле объекта класса Square; возвращаем готовую операцию Square.

Сумма - бинарная операция: она извлекается; строится первый операнд; результат записывается в поле класса Sum; строится второй операнд; второй операнд сохраняется в поле Sum; возвращаем полученный объект Sum.

Пример:

"+ sqr 3 -5"
1. Запускаем построение выражения.
2. '+': создаем объект типа Sum
3. Рекурсивно запускаем построение первого операнда
    3.1. 'sqr': создаем объект типа Square
    3.2. Рекурсивно запускаем построение операнда для Square
        3.2.1. '3': создаем объект Constant(3) возвращаем его в качестве результата.
    3.3. Сохраняем результат рекурсивного вызова в поле объекта Square.
    3.4. Все операнды построены, возвращаем объект Square
4. Сохраняем результат рекурсивного вызова в первое поле объекта Sum.
5. Рекурсивно запускаем построение второго операнда.
    5.1 '-5': создаем объект Constant(-5) возвращаем его в качестве результата.
6. Сохраняем результат рекурсивного вызова во второе поле объекта Sum.
7. Возвращаем объект Sum.

В итоге возвращается следующее бинарное дерево:
    +
   / \
 sqr -5
  |
  3
Видно, что построение дерева разбора выражения сводится к построению первой операции (корня) в массиве (все остальное строится рекурсивно). В случае, если выражение было составлено верно, то в результате рекурсивных вызовов pos окажется в позиции следующей за последним токеном (будет равен длине массива).

Детали реализации
Решение состоит из двух частей - токенизации (уже реализована в части 1) и построения дерева разбора.

В файле expressions.h необходимо объявить классы операций.

IExpression
абстрактный класс для представления произвольной операции.
Содержит единственный публичный метод int Calculate() const, который вычисляет свои операнды и возвращает результат применения операции.
Constant
наследник IExpression.
Имеет конструктор от int, сохраняющий значение константы в свое поле.
Определяет метод Calculate (просто возвращает свое значение).
IUnaryOperation
абстрактный класс, наследник IExpression, представляющий произвольную унарную операцию.
Имеет конструктор от std::unique_ptr<IExpression>, который сохраняет переданный указатель в поле (операнд).
Имеет метод int Operation(int operand) const, который применяет операцию к вычисленному операнду.
Определяет метод Calculate путем вычисления операнда и применения к нему операции.
IBinaryOperation
абстрактный класс, наследник IExpression, представляющий произвольную бинарную операцию
Имеет конструктор от двух std::unique_ptr<IExpression>, который сохраняет переданные указатели в поля (операнды).
Имеет метод int Operation(int lhs, int rhs) const, который применяет операцию к вычисленным операндам.
Определяет метод Calculate путем вычисления операндов и применения к ним операции.
Классы операций Sum (+), Subtract (-), Multiply(*), Divide(/), Residual(%), Minimum(min), Maximum(max), AbsoluteValue(abs), Square(sqr), которые должны быть унаследованы от соответствующих абстрактных классов (IUnaryOperation или IBinaryOperation) и реализовать соответствующий метод Operation. В классы описанные выше вы можете добавлять свои приватные/публичные методы. Самостоятельно определите, какие методы должны быть виртуальными/чисто виртуальными. Для интереса можете добавлять свои операции. Если все реализовано верно, то для этого будет достаточно ввести новый класс и правильно его унаследовать.
Также нужна функция int CalculatePolishNotation(std::string_view input), которая токенизирует вход, строит дерево разбора и запускает вычисление выражения. Прототип и реализацию описать в polish_notation.h и polish_notation.cpp.

Программа должна бросать исключения UnknownSymbolError, если в результате токенизации был получен неизвестный токен; WrongExpressionError, если выражение составлено некорректно.

Гарантируется, что все промежуточные результаты помещаются в int.

Для простоты будем считать, что все токены разделены пробелами (произвольным их количеством).

Замечания.

Вам понадобится токенизатор из предыдущего задания.
В качестве решения пришлите файлы с ВАШИМ кодом из папок calculator/tokenize и calculator/polish_notation (например, tokenize.h tokenize.cpp polish_notation.cpp polish_notation.h expressions.h единым архивом). Тестирующий скрипт самостоятельно разложит их в нужной структуре (относительные пути менять не нужно)

H. Calculator.Calculator
Ограничение времени	1 секунда
Ограничение памяти	64.0 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Когда говорят "компьютерная программа", одно из первых, что приходит на ум, — калькулятор. Действительно, изначальное назначение компьютеров - производить математические вычисления. И кажется, это настолько базовая задача, что написать калькулятор на любом известном вам языке программирования не составляет никакого труда. Тем не менее оказывается, что это не такая уж тривиальная и скучная задача. Как, например, вычислить значение, заданное входом "1 * (((2 * 3) * (4 + 5) + 6 + 7) * (8 * 9 + 10 * 11) * 12)"? Данная задача в трех частях ответит на этот вопрос.

Calculator
Поздравляем, вы добрались до "Босса". В этом задании вы научитесь производить разбор арифметических выражений и реализуете практически полноценный калькулятор.

Основные идеи разбора арифметических выражений во всех подробностях представлены здесь.

TL;DR : Арифметическое выражение - это сумма нескольких (одного и более) слагаемых. Слагаемое - это произведение (деление) нескольких множителей. Множитель - это константа, либо выражение заключенное в скобки. Таким образом, необходимо уметь выделять в исходном тексте каждую из этих трех сущностей в виде гномика.

Парсинг множителя - это простой разбор двух случаев: если следующий токен константа, то множитель - это константа. Если открывающаяся скобка, то множитель равен выражению, стоящему в скобках (обрабатывается с помощью парсинга выражения).

Парсинг выражения начинается с парсинга слагаемого. После этого выражение полагается равным полученному первому слагаемому. Пусть уже построено выражение некоторой длины. Тогда, если следующий элемент это знак + или -, то парсится следующее слагаемое, а выражение полагается равным сумме (разности) уже построенного выражения и нового слагаемого.

Парсинг слагаемого эквивалентен парсингу выражения с точностью до замены знаков +, - на *, /, %.

Пример.

(2 + 3) * 4

1. Парсинг выражения [1] начинается с парсинга слагаемого
2. Парсинг слагаемого [2] вызывает парсинг множителя.
3. Парсинг множителя [3] читает первый токен. Это открывающаяся скобка. Значит необходимо
распарсить выражение, которое стоит внутри.
4. Рекурсивно запускаем парсинг выражения [4], который запускает парсинг слагаемого [5],
который в свою очередь запускает парсинг множителя [6].
5. Парсинг множителя [6] видит константу '2', на этом его полномочия все. Он возвращает
выражение Constant(2).
6. Возвращаемся в [5]. Слагаемое полагаем равным вернувшемуся значению Constant(2).
7. Следующий символ '+', поэтому слагаемое [5] успешно построено. Возвращаем результат.
8. Возвращаемся в [4]. Парсинг слагаемого вернул Constant(2), поэтому пока оно совпадает
с итоговым выражением. Но следующий символ '+', поэтому необходимо распарсить следующее
слагаемое [7].
9. Аналогично [5], [7] вернет слагаемое Constant(3).
10. Возвращаемся в [4]. Парсинг слагаемого [7] вернул Constant(3). Итоговое выражение
полагаем равным сумме (Sum) текущего выражения (Constant(2)) и очередного слагаемого
Constant(3). Следующий символ - закрывающаяся скобка, значит выражение окончено,
возвращаем Sum(Constant(2), Constant(3)) в качестве ответа.
11. Этот результат примет [3] и вернет в качестве ответа.
12. Этот результат попадет в [2]. Текущее значение слагаемого полагается равным
Sum(Constant(2), Constant(3)). Но следующий символ - '*', поэтому запускаем парсинг
второго множителя [8].
13. Парсинг множителя [8] видит, что это константа '4', поэтому сразу возвращает
Constant(4).
14. Возвращаемся в [2]. Слагаемое полагаем равным произведению текущего значения
(Sum(Constant(2), Constant(3))) и Constant(4). Следующего токена нет, поэтому
возвращаем ответ.
15. В [1] попадает Multiply(Sum(Constant(2), Constant(3)), Contant(4)). Токены все
разобраны, поэтому это и есть ответ.
16. Осталось только вызвать Calculate от полученного выражения

    *
   / \
  +   4
 / \
2   3
Детали реализации
Решение состоит из двух частей - токенизация (понадобится токенизатор из части 1) и построение дерева разбора (парсинг).

Используйте классы выражений из задачи PolishNotatin (expressions.h). В этом задании вам понадобятся только операции +, -, *, /, % и константы. Тем не менее подумайте, как поддержать возможность использования других (например, унарных) операций.

В файлах parser.h и parser.cpp объявите и определите функции ParseExpression, ParseAddendum, ParseMultiplier, возвращающие умный указатель на выражение и принимающие const std::vector<Token>& tokens(токены) с size_t& pos (позиция текущего токена).

В файлах calculator.h и calculator.cpp определите функцию int CalculateExpression(std::string_view input), принимающую выражение в виде строки и возвращающую ответ.

Программа должна бросать исключения UnknownSymbolError, если в результате токенизации был получен неизвестный токен и WrongExpressionError, в случае возникновения ошибок при вычислении или разборе (см. примеры в тестах).

Все промежуточные результаты помещаются в int.

Для простоты будем считать, что все токены разделены пробелами (произвольным их количеством).

Замечания.

Решение должно состоять из файлов: tokenize.h и tokenize.cpp (из первой части), expressions.h (из второй), calculator.h, calculator.cpp, parser.h, parser.cpp.

I. UnorderedSet
Ограничение времени	2 секунды
Ограничение памяти	256.0 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt

UnorderedSet
Реализуйте шаблонный класс UnorderedSet, аналог std::unordered_set, который основан на хешировании методом цепочек с динамическим увеличением числа корзин.

Метод цепочек предполагает хранение массива, в каждой ячейке которого лежит корзина - список вставленных элементов с одинаковыми хеш-значениями. Среднее время операций над такой структурой пропорционально степени загруженности таблицы (load_factor = n_elements / n_buckets). При превышении load_factor некоторого значения (в задании = 1) происходит перехеширование - создание нового массива корзин в, например, 2 раза большего размера и перенос старых элементов в новые корзины.

В простейшем варианте достаточно хранить вектор (std::vector) списков (std::list / std::forward_list) и выполнять операции над ним. Более эффективные техники описаны ниже в дополнительных заданиях.

Базовая часть
Шаблонный класс UnorderedSet должен быть параметризован типом ключа KeyT. Стратегия расширения такая же как в задаче String - при добавлении элемента в пустую таблицу число корзин становится равным 1, при добавлении элемента в полную таблицу число корзин увеличивается в 2 раза (таблица считается полной, если число корзин совпадает с числом элементов, то есть load_factor == 1). В качестве хеш-функции воспользуйтесь std::hash. std::hash отображает объекты в диапазон size_t, чтобы получить индекс корзины, возьмите остаток от деления полученного числа на количество корзин.

Набор методов включает:

Конструктор по умолчанию. Создает пустую хеш-таблицу.
Конструктор от числа корзин count. Создает хеш-таблицу с count пустыми корзинами.
Конструктор от промежутка заданного двумя Forward итераторами. Создает хеш-таблицу с числом корзин равным числу элементов в последовательности, а затем вставляет элементы в таблицу.
Конструкторы копирования, перемещения, а также присваивания должны работать корректно.
Методы Size, Empty, Clear с привычной семантикой.
Методы вставки Insert(const KeyT&), Insert(KeyT&&).
Метод удаления Erase(const KeyT&).
Метод поиска bool Find(const KeyT&).
Метод Rehash(new_bucket_count). Изменяет число корзин в хеш-таблице с перехешированием. Если new_bucket_count совпадает с текущим количеством корзин или меньше числа элементов (load_factor становится больше 1), то ничего делать не нужно.
Метод Reserve(new_bucket_count). То же, что и Rehash, но не уменьшает число корзин, то есть срабатывает, если new_bucket_count превышает текущее количество корзин.
Методы BucketCount (возвращает число корзин в таблице), BucketSize(id) (возвращает размер корзины с номером id), Bucket(key) (возвращает номер корзины, в которую попадает объект key), LoadFactor() (возвращает степень заполненности таблицы).
Обратите внимание, что каждый раз создавать новые узлы списков при перехешировании может быть неэффективно. Для переиспользования старых узлов (перебрасывания указателей старых списков) рассмотрите возможность использования метода std::list::splice.

Дополнительное задание к задаче UnorderedSet: итерирование
Если выполнено данное задание, добавьте строку #define ITERATOR_IMPLEMENTED в произвольном месте решения.

Этот пункт предполагает реализацию поддержки итераторов для UnorderedSet:

Определение типов-членов Iterator, ConstIterator, DifferenceType.
Определение методов begin(), end(), cbegin(), cend().
Кажется, что нет никаких проблем пройтись по элементам списка и, допустим, вывести их в консоль, или даже написать итератор для класса UnorderedSet. Однако реализация итерирования может быть осложнена тем, что элементы расположены в разных контейнерах, поэтому логика операции ++ нетривиальная. К тому же, проход по всем элементам таблицы займет O(n_buckets + n_elements) времени (необходимо пройтись по всем корзинам и, если корзина не пуста, пройтись по ее элементам), что очень неэффективно при n_buckets >> n_elements. Хочется добиться линейного от числа элементов обхода, не зависящего от числа корзин (O(n_elements)).

Для решения этих проблем используется следующий подход: элементы хранятся в общем списке, при этом элементы принадлежащие одной корзине лежат последовательно друг за другом. В корзине теперь хранится не список элементов, а итератор на первый элемент списка, принадлежащей ей. Если корзина пуста, то хранится пустой итератор (сконструированный по умолчанию).

Пример:


Пусть хеш таблица устроена следующим образом - [ [0, 1, 2], [], [3, 4], [], [5] ], то есть в корзине 0 расположены
элементы [0, 1, 2], корзина 1 пуста и т.д. Тогда корректный список элементов выглядит, например, так:
[3]<->[4]<->[0]<->[1]<->[2]<->[5]. Массив корзин же выглядит так: 
[ Iterator[0], Iterator[], Iterator[3], Iterator[], Iterator[5]], где Iterator[] - пустой итератор, а Iterator[i] -
итератор, указывающий на элемент со значением i.
Поиск осуществляется линейным проходом от начала корзины до первого элемента не лежащего в ней (это можно определить по хеш-значению), либо до конца списка, если такого встречено не было. Вставка и удаление осуществляется с помощью методов insert и erase для списка по итератору, указанному в корзине, либо с помощью push_front, если корзина пуста. При этом важно аккуратно обновлять итераторы в корзинах при необходимости.

Пример:


Вернемся к примеру: элементы [3]<->[4]<->[0]<->[1]<->[2]<->[5], корзины
[ Iterator[0], Iterator[], Iterator[3], Iterator[], Iterator[5] ]. 
Вставим элемент 6 в корзину 0. Для этого вставим его в список перед элементом [0] и обновим итератор на начало:
[3]<->[4]<->[6]<->[0]<->[1]<->[2]<->[5], [ Iterator[6], Iterator[], Iterator[3], Iterator[], Iterator[5] ]
Удаление 3 состоит в удалении [3] из списка и обновлении итератора 2й корзины на [4].
При удалении 5 итератор 4й корзины становится пустым (корзина опустела).
[4]<->[6]<->[0]<->[1]<->[2], [ Iterator[6], Iterator[], Iterator[4], Iterator[], Iterator[] ]
Итерирование по хеш таблице при такой реализации эквивалентно итерированию по списку элементов.

Полезный факт: при перемещении списка или вызова метода swap итераторы на элементы списка не инвалидируются.

Дополнительное задание (опциональное) : односвязный список
Если выполнено данное задание, добавьте строку #define FORWARD_LIST_IMPLEMENTED в произвольном месте решения.

Правда ли, что нам нужен полный функционал двусвязного списка (std::list) для корректной реализации хеш-таблицы? При поиске мы проходимся по элементам корзины в одном направлении 1 раз, аналогично при вставке и удалении. Обход хеш-таблице так же требует лишь возможности прямого прохода (то есть категории ForwardIterator). Таким образом, оказывается, что список элементов достаточно хранить в односвязном списке (std::forward_list). А если нет разницы, то зачем платить больше (лишние расходы на хранение и поддержку обратных ссылок)?

Казалось бы, ctrl+f std::list + замена std::list -> std::forward_list = халявные баллы. Однако не все так просто. Дело в том, что для удаления из односвязного списка недостаточно иметь итератор на элемент, так как он не хранит ссылки на предыдущий и восстановить связность списка не представляется возможным. Поэтому для удаления необходим итератор на элемент предшествующий удаляемому. Аналогичные проблемы возникают при выполнении операций insert и splice. В связи с этим интерфейс std::forward_list отличается от интерфейса std::list наличием методов insert_after, erase_after, splice_after.

Хорошо, а как удалить первый элемент списка? Или вставить элемент в начало списка? Для этого в std::forward_list используется специальный итератор before_begin(), который указывает на фиктивную вершину в списке, расположенную непосредственно перед нулевым элементом списка.

В связи с указанным выше, в корзинах должны храниться не итераторы на начала корзин, а итераторы на элементы, стоящие перед ними.

Пример:


Хеш-таблица [ [0, 1, 2], [], [3, 4], [], [5] ] теперь представляется односвязным списком
[x]->[3]->[4]->[0]->[1]->[2]->[5], где [x] - фиктивный элемент перед началом списка (before_begin). 
В корзинах хранятся итераторы: [ Iterator[4], Iterator[], Iterator[x], Iterator[], Iterator[2] ]
При вставке и удалении нужно быть внимательным и аккуратно переприсваивать итераторы, так как какая-то из корзин могла ссылаться на удаляемый элемент.

Пример:


[x]->[3]->[4]->[0]->[1]->[2]->[5],  [ Iterator[4], Iterator[], Iterator[x], Iterator[], Iterator[2] ]

Удалим элемент [2]. Несмотря на то, что [2] принадлежит нулевой корзине, его удаление испортит корзину номер 4 (она
ссылается на него, так как он предшествует элементу [5], лежащему в этой корзине). Поэтому необходимо сначала перенести
итератор 4й корзины на элемент [1] (элемент перед [2]) и только потом удалять [2]:
[x]->[3]->[4]->[0]->[1]->[5],  [ Iterator[4], Iterator[], Iterator[x], Iterator[], Iterator[1] ]
Полезный факт: при перемещении односвязного списка или вызова метода swap итераторы на элементы списка не инвалидируются. НО: итератор на элемент before_begin может стать невалидным.