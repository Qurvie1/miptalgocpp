A*. Компаратор
Ограничение времени	0.5 секунд
Ограничение памяти	8Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Юный программист Саша написал свою первую тестирующую систему. Он так обрадовался тому, что она скомпилировалась, что решил пригласить школьных друзей на свой собственный контест.

Но в конце тура выяснилось, что система не умеет сортировать команды в таблице результатов. Помогите Саше реализовать эту сортировку.

Команды упорядочиваются по правилам ACM:

по количеству решённых задач в порядке убывания;
при равенстве количества решённых задач – по штрафному времени в порядке возрастания;
при прочих равных — по номеру команды в порядке возрастания.
Используйте в этой задаче std::vector, std::sort и собственный компаратор.

Формат ввода
Первая строка содержит натуральное число n (1 ≤ n ≤ 105) — количество команд, участвующих в контесте.

В i-й из следующих n строк записано количество решенных задач S (0 ≤ S ≤ 100) и штрафное время T (0 ≤ T ≤ 105) команды с номером i.

Формат вывода
В выходной файл выведите n чисел — номера команд в отсортированном порядке.

B*. Зверюшки
Ограничение времени	1 секунда
Ограничение памяти	8Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Уже долгое время в Институте Мутантов, Фич Технологических и Иностранных языков разводят милых разноцветных зверюшек. Для удобства каждый цвет обозначен своим номером, всего цветов не более 109.

В один из прекрасных дней в питомнике случилось чудо: все зверюшки выстроились в ряд в порядке возрастания цветов. Пользуясь случаем, лаборанты решили посчитать, сколько зверюшек разных цветов живет в питомнике, и, по закону жанра, попросили вас написать программу, которая поможет им в решении этой нелегкой задачи.

Для решения этой задачи используйте std::vector и библиотеку algorithm.

Формат ввода
В первой строке входного файла содержится единственное число N (0 ≤ N ≤ 105) — количество зверюшек в Институте.

В следующей строке находятся N упорядоченных по неубыванию неотрицательных целых чисел, не превосходящих 109 и разделенных пробелами — их цвета.

В третьей строке файла записано число M (1 ≤ M ≤ 100000) — количество запросов вашей программе, в следующей строке через пробел записаны M целых неотрицательных чисел (не превышающих 109+1).

Формат вывода
Выходной файл должен содержать M строчек. Для каждого запроса выведите число зверюшек заданного цвета в питомнике.

C*. Встреча
Ограничение времени	0.5 секунд
Ограничение памяти	8Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Напишите программу, которая определяет, сколько раз встречается заданное число x в данном массиве. Используйте последовательный контейнер и библиотеку алгоритмов для решения задачи. Старайтесь избегать циклов.

Формат ввода
В первой строке задается одно натуральное число N, не превосходящее 1,000,000 — размер массива.

Во второй строке вводятся N чисел — элементы массива (целые числа, не превосходящие по модулю 1,000).

В третьей строке содержится одно целое число x , не превосходящее по модулю 1,000,000.

Формат вывода
Вывести одно число — сколько раз встречается x в данном массиве.

D*. Список смежности
Ограничение времени	1 секунда
Ограничение памяти	8Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
В этой задаче необходимо организовать неориентированный граф, на котором поддерживаются следующие операции:

AddEdge(u, v) — добавить в граф ребро между вершинами (u, v).
Vertex(u) — вывести список вершин, смежных с вершиной u.
Петель и кратных ребер в графе нет. Для решения данной задачи используйте последовательные контейнеры из STL.

Формат ввода
В первой строке входного файла содержится целое число N (1 ≤ N ≤ 106) — количество вершин в графе.

В следующей строке находится целое числоK (0 ≤ K ≤ 106) — число операций, затем идет описание операций — каждое в своей строке.

Операции имеют следующий формат: «1 u v » или «2 u », обозначающие соответственно операции AddEdge(u, v) и Vertex(u).

Гарантируется, что суммарное количество чисел, которое будет необходимо вывести при выполнении всех операций Vertex не превосходит 2⋅ 105.

Формат вывода
В выходной файл для каждой команды Vertex необходимо на отдельной строке вывести список смежных вершин указанной вершины. Вершины списка смежности нужно выводить в порядке добавления соответствующих ребер в граф.

E*. Словарь
Ограничение времени	1 секунда
Ограничение памяти	256Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Вам дан словарь, состоящий из пар слов. Каждое слово является синонимом к парному ему слову. Все слова в словаре различны. Для каждого данного слова определите его синоним.

Для решения данной задачи используйте std::unordered_map

Формат ввода
Программа получает на вход количество пар синонимов N (0 ≤ N ≤ 105). Далее следует N строк, каждая строка содержит ровно два слова-синонима.

Затем идет число Q (1 ≤ Q ≤ 105) — количество запросов к словарю. Далее на каждой следующей из Q строк идет слово, к которому надо вывести синоним.

Формат вывода
Программа должна вывести синонимы к данным слову на отдельных строках.

F*. Банк
Ограничение времени	0.5 секунд
Ограничение памяти	8Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
У банка есть клиенты. Каждый клиент имеет ровно один счет.

Напишите программу, которая будет выполнять последовательность запросов таких двух видов:

Начинается с числа 1, затем через пробел следует имя клиента (слово из латинских букв), далее через пробел идет сумма денег, которую клиент кладет или берет из счета в банке (целое число, не превышает по модулю 10000).
Начинается с числа 2, через пробел следует имя клиента. На каждый такой запрос программа должна ответить какая сумма в данный момент есть на счету заданного клиента. Если такое имя клиента пока ни разу не упоминалось в запросах вида 1, выводите вместо числа слово «ERROR».
В начале работы программы у всех клиентов на счету 0. Затем суммы могут становиться как положительными, так и отрицательными.

Обратите внимание, что в ситуации, когда клиент снял суммарно ровно столько же денег, сколько положил, сумма на счете становится равной 0, но, раз его имя уже встречалось, нулевое значение не является основанием выводить «ERROR».

Для решения задачи используйте ассоциативный контейнер.

Формат ввода
Первая строка стандартного входного потока количество запросов N (1 ≤ N ≤ 105). Далее следуют N строк в каждой из которых описан один из двух описанных выше видов запроса.

Формат вывода
На каждый запрос 2-го вида нужно вывести текущее значение на счету заданного клиента (или слово «ERROR»).

G*. Частотность
Time limit	0.5 секунд
Memory limit	32Mb
Input	stdin or input.txt
Output	stdout or output.txt
Legend
Дан текст. Выведите все слова, встречающиеся в тексте, по одному на каждую строку. Слова должны быть отсортированы по убыванию их количества появления в тексте, а при одинаковой частоте появления в лексикографическом порядке.

Input format
Вводится текст — последовательность строк через пробел или перенос строки.

Output format
Выведите ответ на задачу.

H*. База данных
Ограничение времени	0.5 секунд
Ограничение памяти	32Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Дана база данных о продажах некоторого интернет-магазина. Каждая строка входного файла представляет собой запись вида покупатель-товар-количество , где покупатель — имя покупателя (строка без пробелов), товар — название товараc (строка без пробелов), количество — количество приобретённых единиц товара.

Создайте список всех покупателей и для каждого покупателя подсчитайте количество приобретенных им единиц каждого вида товаров.

Формат ввода
Во входном файле записано не более 105 строк в указанном формате.

Имена покупателей и названия товаров представляют собой строки из заглавных и строчных латинских букв не длиннее 10 символов. Количество товара в каждой покупке — натуральное число, не превышающее 106.

Формат вывода
Выведите список всех покупателей в лексикографическом порядке, после имени каждого покупателя выведите двоеточие, затем выведите список названий всех приобретенных данным покупателем товаров в лексикографическом порядке, после названия каждого товара выведите количество единиц товара, приобретенных данным покупателем.

Информация о каждом товаре выводится в отдельной строке.

I*. Недешевый калькулятор
Ограничение времени	0.1 секунда
Ограничение памяти	8Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Студенты ФПМИ придумали новую версию калькулятора. Этот калькулятор берет с пользователя валюту за совершаемые операции. Стоимость каждой операции в ФПМИ-коинах равна 5% от числа, которое является результатом операции.

На этом калькуляторе требуется вычислить сумму N натуральных чисел (числа, так уж и быть, известны). Нетрудно заметить, что от того, в каком порядке мы будем складывать эти числа, иногда зависит, в какую ФПМИ-коинов нам обойдется вычисление суммы чисел (то есть оказывается нарушено великое правило «от перестановки мест слагаемых сумма не меняется»).

Например, пусть нам нужно сложить числа 10, 11, 12, 13. Подумайте, как от порядка вычислений зависит ответ. Напишите программу, используя std::priority_queue или функции для работы с пирамидой из <algorithm>, которая будет определять, за какую минимальную сумму ФПМИ-коинов можно найти сумму данных N чисел.

Формат ввода
Во входном файле записано число N (2 ≤ N ≤ 105). Далее идет N натуральных чисел, которые нужно сложить, каждое из них не превышает 104.

Формат вывода
В выходной файл выведите, сколько ФПМИ-коинов нам потребуется на нахождение суммы этих N чисел.

J*. Stack
Ограничение времени	1 секунда
Ограничение памяти	64.0 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Stack

Контейнерные адаптеры представляют собой обертку над последовательными контейнерами, которые предоставляют ограниченный интерфейс взаимодействия соответствующий определенному абстрактному типу данных.

Задание
Реализуйте контейнерный адаптер Stack, аналог std::stack, параметризованный шаблонным типом хранимых элементов T и контейнером Container, который лежит в его основе (значение по умолчанию - std::deque<T>). Реализуйте следующие методы:

Конструктор по умолчанию;
Конструктор от контейнера Container;
Конструктор от пары итераторов;
Top();
Empty();
Size();
Push(value);
Emplace(args...)
Pop();
Swap(Stack&).

K*. Vector
Ограничение времени	20 секунд
Ограничение памяти	128.0 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt

Пришлите архив с файлом vector.h и, возможно, другими файлами реализации.

Vector
Ранее в курсе был рассмотрен класс динамической строки std::string (см. задание String), которая увеличивает размер массива символов по мере необходимости и самостоятельно управляет выделяемой памятью. В этом задании мы рассмотрим класс std::vector, являющийся обобщением динамической строки на произвольный тип, то есть класс динамического массива.

std::vector
Интерфейс и реализация std::vector<T> во многом похожи на std::string. Ключевым отличием является семантика работы метода reserve (и остальных методов, которые приводят к увеличению capacity). При резервировании памяти под большее число объектов, выделяется "сырая" (неинициализированная) память достаточная для хранения нужного числа дополнительных объектов. Пустые ячейки заполняются лениво по мере необходимости. То есть, если size < capacity, то это значит, что первые size * sizeof(T) байт реально заняты объектами, а последние (capacity - size) * sizeof(T) байт пусты - объектов там не создано (как такого добиться - см. задание Optional). Это нужно, например, для того, чтобы можно было создавать вектор из объектов, у которых нет конструктора по умолчанию (а как бы тогда нужно было инициализировать неиспользуемые ячейки?):

struct A {
  int x;

  A() = delete;
  explicit A(int x_param) : x(x_param) {
  }
};

std::vector<A> v;
v.reserve(1000);  // объекты A не создаются! Выделяется "сырая" память размера 1000 * sizeof(A)
for (int i = 0; i < 1000; ++i) {
  v.push_back(A(i));
  // а лучше v.emplace_back(i);
}
Подробности на лекциях, семинарах, в чатах, на заборе, а также в справочнике.

Детали реализации
От вас требуется реализовать шаблонный класс Vector с единственным шаблонным параметром - типом хранящихся элементов. При реализации можно (и даже нужно) пользоваться обобщенными алгоритмами из STL (std::copy, std::fill и т.п.), но нельзя использовать стандартные контейнеры. Будет проверяться корректность мультипликативной схемы расширения массива с коэффициентом 2. В базовой версии ручное управление временем жизни объектов не требуется (см. доп. задание). Класс должен поддерживать следующий функционал:

Конструктор по умолчанию - создает пустой массив;
Явный конструктор от числа - создает массив заданного размера заполненный объектами, сконструированными по умолчанию;
Конструктор, принимающий size и value (именно в этом порядке) - создает массив длины size, заполненный элементами со значением value;
Шаблонный конструктор, принимающий пару итераторов - создает копию переданного диапазона;
Важно: объявление этого конструктора должно иметь вид

template <class Iterator, class = std::enable_if_t<std::is_base_of_v<std::forward_iterator_tag, typename std::iterator_traits<Iterator>::iterator_category>>>

Vector(Iterator first, Iterator last)

Это делает конструктор доступным только в случае, когда на вход приходят два Forward итератора.

Конструктор от std::initializer_list;
Правило "пяти";
Методы Size, Capacity, Empty;
Константный и неконстантный оператор доступа по индексу []. Неконстантный должен позволять изменять полученный элемент;
Константный и неконстантный метод доступа по индексу At. При выходе за границы массива должен бросать исключение std::out_of_range;
Методы Front() и Back()
доступ к первому и последнему элементам (тоже по две версии).
Метод Data()
возвращает указатель на начало массива.
Метод Swap(other)
обменивает содержимое с другим массивом other;
Метод Resize(new_size)
изменяет размер на new_size. Если вместимость не позволяет хранить столько элементов, то выделяется новый буфер с вместимостью new_size. Недостающие элементы конструируются по умолчанию.
Метод Resize(new_size, value)
то же, что и Resize(new_size), но в случае new_size > size заполняет недостающие элементы значением value.
Метод Reserve(new_cap)
изменяет вместимость на max(new_cap, текущая вместимость). Размер при этом не изменяется.
Метод ShrinkToFit()
уменьшает capacity до size.
Метод Clear()
устанавливает размер в 0, очищения выделенной памяти при этом НЕ происходит.
Методы PushBack(const T&) и PushBack(T&&)
добавляет новый элемент в конец массива.
Метод PopBack()
удаляет последний элемент.
Операции сравнения (<, >, <=, >=, ==, !=), задающие лексикографический порядок.
Также реализуйте поддержку итераторов и методы для работы с ними: begin(), end(), cbegin(), cend(), rbegin(), rend(), crbegin(), crend(). begin()-end(), rbegin()-rend() должны иметь две версии, возвращающие константные и неконстантные итераторы.

Внутри класса Vector определите типы-члены ValueType, Pointer, ConstPointer, Reference, ConstReference, SizeType, Iterator, ConstIterator.

Гарантии безопасности
Спроектируйте класс так, чтобы при возникновении исключений (нехватка памяти, ошибка при копировании объектов и т.п.) методы удовлетворяли строгой гарантии безопасности. То есть все методы должны работать атомарно: либо работать без сбоев, либо не изменять исходного состояния вектора. Исключение: копирующее присваивание может давать лишь базовую гарантию безопасности.

При решении можно предполагать, что конструкторы перемещения, перемещающие присваивания и деструкторы объектов никогда не бросают исключений!

L*. Optional
Ограничение времени	1 секунда
Ограничение памяти	64.0 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt

Пришлите файл optional.h.

Optional
Это задание познакомит вас с основами ручного управления временем жизни объектов на примере класса Optional.

При создании объектов на стеке компилятор самостоятельно выделяет память достаточную для хранения объекта и инициализирует объект, вызывая соответствующий конструктор, а при выходе из блока самостоятельно очищает память и завершает время жизни объекта посредством вызова деструктора.

Если речь идет про динамическую область памяти, то этот процесс частично контролируется пользователем - операция new заставляет выделить память под объект в куче и создать его там же, операция delete инициирует вызов деструктора и освобождает выделенную память.

А что, если хочется самостоятельно определять в какой момент объект должен быть создан и уничтожен, то есть не привязывать время жизни объекта к памяти, которая его содержит? Это может быть полезно, например, для эффективной работы std::vector<T> - если объекты типа T требуют много ресурсов на создание, то может быть накладно иметь capacity объектов, когда реально используется только size из них. Для решения этой проблемы std::vector хранит лишь "сырую" память достаточную для хранения capacity объектов, а сами объекты создаются и удаляются вручную по мере необходимости.

Placement new и явный вызов деструктора
Для ручного создания объекта по конкретному месту в памяти (заранее выделенного на стеке или в куче) можно воспользоваться специальной формой оператора new - placement new.

Пусть ptr - указатель на область памяти достаточного размера для хранения объекта типа T. Чтобы создать объект в данном месте можно воспользоваться следующим синтаксисом: c++ new(ptr) T(args...); // args... - аргументы конструктора

Заметьте, что отличие состоит в явном указании адреса в скобках и отсутствии выделения дополнительной памяти.

Приведем пример неправильного использования placement new:

A a;                 // создаем объект типа A
new(&a) A("param");  // пересоздаем объект, деструктор старого объекта при этом не вызывается!
Для корректной работы предыдущего примера необходимо удалить старый объект перед созданием нового: c++ A a; // создаем объект типа A a.~A(); // явно вызываем деструктор старого объекта new(&a) A("param"); // создаем новый объект

Код вида a = A("param"); логически эквивалентен приведенному выше, но отличается с точки зрения времени жизни объектов. Кроме того, код выше работает и в случае, когда для класса A не определен оператор присваивания.

Важно отметить, что после последнего создания явно вызвать деструктор не нужно, так как компилятор вызывает его самостоятельно при выходе из блока: c++ A a; // создаем объект типа A a.~A(); // явно вызываем деструктор старого объекта new(&a) A("param"); // создаем новый объект a.~A(); // UB: деструктор вновь вызовется при выходе из блока

Для создания объекта "с нуля" в сырой памяти нужно сначала предоставить эту память, а затем приступить к созданию:

char memory[sizeof(A)];  // создаем сырую память размера sizeof(A) байт
A* obj = new(memory) A("param");  // создаем объект A, возвращается тот же указатель, но типа A*
// ... use of A
obj->~A();  // важно самостоятельно вызвать деструктор! memory будет освобожден как массив char, а не как объект A
Аналогичный пример в динамической памяти: c++ char* memory = new char[sizeof(A)]; // или operator new(sizeof(A)); A* obj = new(memory) A("param"); // ... use of A obj->~A(); delete[] memory; // так как выделяли массив char, то и удалять нужно массив char // или operator delete(memory);

Вместо массива char в качестве сырой памяти под объекты можно использовать стандартный тип std::aligned_storage_t.

std::optional (C++17)
Шаблон std::optional предоставляет безопасный интерфейс для управления временем жизни объектов. Он принимает ровно 1 шаблонный параметр (тип хранимого объекта) и может находиться в одном из двух состояний - объект жив или объект мертв.

В любой момент времени можно узнать состояние объекта (has_value), или изменить его (emplace, reset). При этом класс самостоятельно принимает решение о том в какой момент вызывать деструктор/конструктор объекта, освобождая пользователя от этих забот.

Пример:

std::optional<std::vector<int>> opt;  // opt не содержит внутри себя вектора (даже пустого)
opt.has_value();  // false
opt = std::vector<int>(3);  // теперь содержит вектор из 3 чисел
opt.has_value();  // true
(*opt)[2];  // для обращения к объекту нужно "разыменовать" opt или вызвать метод value()
opt.reset();  // вектор уничтожен, opt теперь ничего не хранит
Этот класс может быть полезен, например, для реализации функций, которые не всегда должны что-то возвращать:

std::optional<double> Divide(double x, double y) {
    if (y == 0.0) {
        return {};  // или std::nullopt
    }
    return x / y;
}

auto res = Divide(1.0, 0.0);
if (res) {  // умеет неявно преобразовываться в bool
    std::cout << *res;
}
Детали реализации
Реализуйте шаблон Optional<T>, упрощенный аналог std::optional<T>. В полях шаблона сохраните память (массив char или std::aligned_storage_t) достаточного размера (память должна располагаться на стеке!), а также булевское поле, в котором будет храниться информация о том жив ли объект. Шаблонный класс должен поддерживать следующие методы:

Конструктор по умолчанию. Создает Optional с "мертвым" объектом.
Конструктор копирования. Создает копию, если копируемый объект жив, и пустой Optional иначе.
Конструктор перемещения. Если перемещаемый Optional пуст, то создается пустой объект. Иначе перемещаем объект из другого Optional. При этом старый Optional по прежнему остается живым!
Неявный конструктор от const T& и T&&. Создает Optional созданный с помощью переданного объекта (копированием или перемещением)
Деструктор. Вызывает деструктор объекта, если тот жив, и ничего не делает, если мертв.
Копирующее и перемещающее присваивание. Если копируемый(перемещаемый) объект мертв, то и свой объект становится мертвым. Иначе своему объекту нужно соответствующим образом присвоить другой (и если был мертв, то оживить).
Присваивание от const T& и T&&. Аналогично предыдущему (только копируемый объект априори жив).
bool HasValue(). Возвращает жив объект, либо нет.
Явное приведение к bool. Аналогично предыдущему.
Value(). Возвращает ссылку на объект. Если объект мертв, то бросается исключение BadOptionalAccess (которое тоже надо реализовать). Поддержать константную и неконстантную версии.
Константный и неконстантный `operator*. Аналогичен Value`, но не осуществляет проверок.
T& Emplace(args...). Принимает аргументы конструктора, с которыми нужно пересоздать объект (если он был жив, то вызвать деструктор и создать заново).
void Reset(). Уничтожить объект, если тот был жив.
Замечания.

https://en.cppreference.com/w/cpp/utility/optional
Существует неприятная проблема связанная с использованием указателя на "сырую" память, которая была ранее занята другим объектом (https://en.cppreference.com/w/cpp/utility/launder). Для упрощения реализации мы игнорируем эту проблему (она проявляется только при работе с объектами с константными или ссылочными полями, в тестах таких случаев нет).

M. Vector+
Ограничение времени	20 секунд
Ограничение памяти	128.0 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt

Перед решением этой части настоятельно рекомендуется решить задачу Optional!

Дополнительная часть к задаче Vector (работа с памятью)
Реализуйте полноценное управление памятью, описанное во второй секции основного задания. То есть в каждый момент времени должно существовать ровно size объектов. При добавлении элементов (например, с помощью PushBack, либо Resize) новые элементы должны создаваться вручную с помощью placement new, а при удалении элемента (например, с помощью PopBack или Clear) для него вручную должен вызываться деструктор (либо std::destroy и std::destroy_at).

При решении можно использовать алгоритмы стандартной библиотеки для работы с неинициализированной памятью (секция uninitialized storage). Они значительно упростят работу.

Добавьте директиву #define VECTOR_MEMORY_IMPLEMENTED в файл с решением, если решили эту часть.

N. Itertools.Range
Ограничение времени	1 секунда
Ограничение памяти	64.0 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt

Itertools
Одним из минусов языка C++ является отсутствие удобного интерфейса работы с последовательностями и промежутками значений, который, по большому счету сводится к ручному написанию циклов и работе со встроенными итераторами. С введением библиотеки в C++20 ситуация заметно улучшилась. В этом цикле задач мы попытаемся решить заявленную проблему средствами C++17.

Range
Для написания цикла по целым значениям в C++ необходимо написать следующий код:


for (int i = 0; i < end; ++i) {
    // ...
}

for (int i = begin; i < end; ++i) {
    // ...
}

for (int i = begin; i < end; i += step) {
    // ...
}
Сравните, например, с языком Python:


for i in range(end):
    # ...

for i in range(begin, end):
    # ...

for i in range(begin, end, step):
    # ...
Хотелось бы иметь подобный лаконичный код и в C++ (благо range-based for завезли в C++11):


for (int i : range(end)) {
    // ...
}

for (int i : range(begin, end)) {
    // ...
}

for (int i : range(begin, end, step)) {
    // ...
}
Проблема в том, что в стандартной библиотеке (до C++20) нет сущности range, которую можно было использовать в подобном контексте. Ну а раз так - надо ее реализовать самостоятельно!

Детали реализации
Необходимо реализовать Range (класс или функцию), который возвращает объект некоторого класса (вам нужно его реализовать) с определенными методами begin и end. Эти методы должны возвращать итератор (его тоже нужно реализовать), который при разыменовывании возвращает соответствующее целое значение, а при инкрементировании увеличивает свое состояние на step (по умолчанию step == 1).

Примеры: (больше примеров см. в тестах)


for (int i : Range(3)) { ... }  // i in [0, 1, 2]

for (int i : Range(3, 6)) { ... }  // i in [3, 4, 5]

for (int i : Range(3, 6, 2)) { ... }  // i in [3, 5]

for (int i : Range(6, 1, -2)) { ... }  // i in [6, 4, 2]
Указание: вспомните как работает range-based for в C++.

Дополнительное задание
Поддержать обратные итераторы (см. примеры в тестах). Добавьте директиву #define REVERSE_RANGE_IMPLEMENTED в файл с решением для проверки дополнительного задания.

O. Itertools.Enumerate
Ограничение времени	1 секунда
Ограничение памяти	64.0 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt

Itertools
Одним из минусов языка C++ является отсутствие удобного интерфейса работы с последовательностями и промежутками значений, который, по большому счету сводится к ручному написанию циклов и работе со встроенными итераторами. С введением библиотеки в C++20 ситуация заметно улучшилась. В этом цикле задач мы попытаемся решить заявленную проблему средствами C++17.

Enumerate
Для прохода по контейнеру, который не поддерживает индексацию ([]), и хранения порядкового номера текущего элемента необходимо поддерживать его самостоятельно в отдельной переменной:


int i = 0;
for (auto it = container.begin(); it != container.end(); ++it, ++i) {
    // ...
}
Сравните, например, с языком Python:


for i, x in enumerate(container):
    # ...
Хотелось бы иметь подобный лаконичный код и в C++ (благо range-based for завезли в C++11):


for (auto&& [i, x] : enumerate(container)) {
    // ...
}
Проблема в том, что в стандартной библиотеке (до C++20) нет сущности enumerate, которую можно было использовать в подобном контексте. Ну а раз так - надо ее реализовать самостоятельно!

Детали реализации
Необходимо реализовать Enumerate (класс или функцию), который возвращает объект некоторого класса (вам нужно его реализовать) с определенными методами begin и end. Эти методы должны возвращать итераторы, которые помимо стандартного итератора контейнера хранят порядковый номер элемента, а при разыменовывании возвращают пару "индекс-элемент".

Примеры: (больше примеров см. в тестах)


std::list<int> l{1, 2, 3, 4, 5};

for (auto p : Enumerate(l)) { ... }  // p in [{0, 1}, {1, 2}, {2, 3}, {3, 4}, {4, 5}]

for (auto&& [i, x] : Enumerate(l)) {
    x = 0;
}
// l == {0, 0, 0, 0, 0}
Указание: вспомните как работает range-based for в C++.

Дополнительное задание
При наивной реализации (описанной в задании) Enumerate не сможет работать со временными контейнерами:


for (auto&& [i, x] : Enumerate(std::vector<int>{1, 2, 3, 4, 5})) { ... }  // Undefined behaviour!
Это связано с тем, что цикл будет работать с "висячими" (невалидными) итераторами, так как контейнер, на который они ссылаются, будет уничтожен.

Решить эту проблему можно с помощью специализации Enumerate на случай rvalue объектов. В этом случае в полях класса необходимо сохранять не итераторы begin и end, а контейнер целиком. Так мы гарантируем, что сохраненный контейнер не будет уничтожен до выхода из цикла, и итераторы всегда будут ссылаться на живой объект.

Добавьте директиву #define TEMPORARY_ENUMERATE_IMPLEMENTED в файл с решением для проверки дополнительного задания.

P. Itertools.Reversed
Ограничение времени	1 секунда
Ограничение памяти	64.0 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt

Itertools
Одним из минусов языка C++ является отсутствие удобного интерфейса работы с последовательностями и промежутками значений, который, по большому счету сводится к ручному написанию циклов и работе со встроенными итераторами. С введением библиотеки в C++20 ситуация заметно улучшилась. В этом цикле задач мы попытаемся решить заявленную проблему средствами C++17.

Reversed
Для прохода по контейнеру в обратном порядке в C++ необходимо написать подобный код:


for (auto it = container.rbegin(); it != container.rend(); ++it) {
    // ...
}
Сравните, например, с языком Python:


for x in reversed(container):
    # ...
Хотелось бы иметь подобный лаконичный код и в C++ (благо range-based for завезли в C++11):


for (auto&& x : reversed(container)) {
    // ...
}
Проблема в том, что в стандартной библиотеке (до C++20) нет сущности reversed, которую можно было использовать в подобном контексте. Ну а раз так - надо ее реализовать самостоятельно!

Детали реализации
Необходимо реализовать Reversed (класс или функцию), который возвращает объект некоторого класса (вам нужно его реализовать) с определенными методами begin и end. Эти методы должны возвращать соответствующие обратные итераторы переданного контейнера.

Примеры: (больше примеров см. в тестах)


std::vector<int> v{1, 2, 3, 4, 5};

for (int x : Reversed(v)) { ... }  // x in [5, 4, 3, 2, 1]

for (int& x : Reversed(v)) {
    x = 0;
}
// v == {0, 0, 0, 0, 0}
Указание: вспомните как работает range-based for в C++.

Дополнительное задание 1
Поддержать обратные итераторы (см. примеры в тестах). Добавьте директиву #define REVERSE_REVERSED_IMPLEMENTED в файл с решением для проверки дополнительного задания.

Дополнительное задание 2
При наивной реализации (описанной в задании) Reversed не сможет работать со временными контейнерами:


for (auto x : Reversed(std::vector<int>{1, 2, 3, 4, 5})) { ... }  // Undefined behaviour!
Это связано с тем, что цикл будет работать с "висячими" (невалидными) итераторами, так как контейнер, на который они ссылаются, будет уничтожен.

Решить эту проблему можно с помощью специализации Reversed на случай rvalue объектов. В этом случае в полях класса необходимо сохранять не итераторы rbegin и rend, а контейнер целиком. Так мы гарантируем, что сохраненный контейнер не будет уничтожен до выхода из цикла, и итераторы всегда будут ссылаться на живой объект.

Добавьте директиву #define TEMPORARY_REVERSED_IMPLEMENTED в файл с решением для проверки дополнительного задания.