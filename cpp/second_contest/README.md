A*. Array
Ограничение времени	1 секунда
Ограничение памяти	64.0 Мб
Ввод	стандартный ввод
Вывод	стандартный вывод

Array
C-style массивы эффективней в использовании чем массивы в динамической памяти, из-за известного на этапе компиляции фиксированного размера и более эффективного расположения в памяти (стековая/автоматическая память). Однако едва ли C-массивы можно назвать удобными в использовании - они спонтанно приводятся к указателям, их не так просто передать в функцию, не работает привычная операция присваивания и т.д. В этой задаче предлагается написать ООП обертку над C-style массивом, который обладает всеми его преимуществами, нивелируя при этом описанные недостатки.

std::array (C++11)
Начиная с C++11 в стандартной библиотеке (заголовочный файл ) появился шаблонный класс std::array, параметризованный типом хранимых элементов T и размером N. Этот класс содержит единственное поле типа "массив T из N элементов" и предоставляет методы для удобного доступа к информации (размер, элементы и т.д), а также изменения элементов массива. Класс std::array в полной мере обеспечивает функционал обычных массивов, не теряя при этом эффективности. Поэтому в современном C++ принято использовать именно std::array вместо C-style массивов. Подробнее.

Детали реализации
Вам необходимо реализовать шаблонный класс Array - упрощенный аналог std::array. Ваш класс должен быть параметризован типом хранимых элементов, а также размером массива. Как было сказано ранее, этот класс должен иметь ровно одно поле - C-style массив требуемого типа и размера. Важным моментом является то, что это поле должно быть публичным! В этом случае, как известно, становится доступна агрегатная инициализация вашего массива:

int arr[4]{1, 2, 3};  // массив {1, 2, 3, 0}
Array my_arr{1, 2, 3};  // если поле публично, то {1, 2, 3, 0}, иначе - CE
Для корректного прохождения тестов ваш класс должен реализовывать следующие методы (подумайте, какие методы должны быть константными, какие - неконстантными, а какие должны иметь обе версии):

Операция [] для доступа к элементу массива по индексу;
Методы Front() и Back() для доступа к первому и последнему элементу соответственно;
Метод Data(), возвращающий указатель на начало массива;
Метод Size(), возвращающий размер массива;
Метод Empty(), возвращающий true, если массив пуст, и false в противном случае;
Метод Fill(const T& value), который заполняет массив значениями value;
Метод Swap(Array& other), обменивающий содержимое массивов одинакового размера.
Замечания.

Проверка устроена таким образом, что требует от вас жесткого следования принятым (выше) сигнатурам и именованиям сущностей (то есть никакие MyArray, __array_, back, superSolver3000 не пройдут). Если вы реализовали требуемый функционал не полностью или интерфейс отличается от заявленного, в ответ вы получите ошибку компиляции.
Решение должно состоять из одного файла array.h с определением класса.
В задаче нет скрытых тестов - все тесты публичные (array_public_test.cpp).
Дополнительная часть
С помощью механизма перегрузки шаблонов реализуйте функции для извлечения свойств C-style массивов:

GetSize(array) должна возвращать число элементов в массиве array и 0, если array не является C-style массивом
GetRank(array) должна возвращать число координат многомерного массива array
GetNumElements(array) должна возвращать общее число элементов в многомерном массиве array
Пример

int x;
int a[3];
int b[3][2][1];

std::cout << GetSize(x) << ' ' << GetSize(a) << ' ' << GetSize(b) << '\n';  // 0 3 3
std::cout << GetRank(x) << ' ' << GetRank(a) << ' ' << GetRank(b) << '\n';  // 0 1 3
std::cout << GetNumElements(x) << ' ' << GetNumElements(a) << ' ' << GetNumElements(b) << '\n';  // 1 3 6
Важно: если вы выполнили это задание, добавьте в файл array.h следующую строку, чтобы в тесты была включена проверка этого задания.

#define ARRAY_TRAITS_IMPLEMENTED

B*. StringView
Ограничение времени	1 секунда
Ограничение памяти	64.0 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt

StringView
В этом задании вам предстоит реализовать класс, который представляет собой невладеющую обертку над C-style строками, совмещающий в себе их легкость и удобство использования от ООП.

std::string_view (C++17)
Класс std::string (которым пользоваться все еще пока запрещено) в большинстве случаев удобнее в использовании, безопаснее и иногда эффективнее C-style строк. Однако бывают ситуации, в которых использование последних гораздо предпочтительнее. Например, обращение к элементам строки это всегда (ну, или почти всегда) обращение к памяти в куче, что требует некоторых накладных расходов. Также часто приходится заводить константные строки со статическим временем жизни (обозначение допустимых команд принимаемых программой и т.п.) и для каждой из них необходимо вызвать конструктор, выделить память в куче, заполнить... В то время как строковые литералы заводятся в статической области памяти еще до начала выполнения программы. А если глобальный (статический) объект std::string бросит исключение при создании? Тогда его нельзя будет обработать и программа аварийно завершится, так толком и не начав работать.

Хорошо, давайте в этих ситуациях использовать const char*. Но это же снова strlen, работающий за линейное время, strcmp вместо операторов сравнения, небезопасный доступ к данным...

В C++17 появился класс std::string_view, который является легковесной оберткой над C строками. Все, что он хранит,- это указатель на константную последовательность символов и ее размер. Для доступа и работы с ней используются интуитивно понятные методы без необходимости задумываться о завершающем нулевом символе. Более того, последовательность символов не обязана быть нуль-терминированной, так как размер строки хранится в отдельном поле. Таким образом, мы нивелируем недостатки const char*, в полной мере используя его преимущества.

Пример:

const char* cstyle = "very_very_long_string_here";  // c-style строка

std::string s = cstyle;  // выделение памяти в куче (долго + потенциально небезопасно)

std::string_view sv = cstyle;  // просто сохраняем указатель в поле класса и вычисляем длину

std::strlen(cstyle);  // всегда O(n)

sv.size();  // всегда O(1)
Детали реализации
Идея описана выше. Особенностей реализации нет (как слышится так и пишется).

Реализуйте класс StringView с поддержкой:

Конструктора по умолчанию (nullptr строка).
Конструктора от const char* (с подсчетом длины). Этот конструктор должен допускать неявные преобразования. Чтобы на это не ругался линтер, добавьте к строке с объявлением комментарий "// NOLINT".
Конструктора от const char* и size_t (длина передается вторым параметром).
Операции [].
Методов Front() и Back(), которые возвращают первый и последний символ строки соответственно.
Методов Size() и Length(), которые возвращают длину строки.
Метод Empty() проверяет строку на пустоту.
Метод Data() возвращает указатель на начало строки.
Метода Swap(StringView&).
Метода RemovePrefix(size_t prefix_size), который сдвигает начало строки на prefix_size.
Метода RemoveSuffix(size_t suffix_size), который сдвигает конец строки на suffix_size.
Метода Substr(size_t pos, size_t count = -1), который формирует из вызывающего объекта StringView на подстроку с началом pos и длины min(count, Size() - pos).
Замечания. 1. https://en.cppreference.com/w/cpp/string/basic_string_view

Решение должно состоять из двух файлов: string_view.h и string_view.cpp
В задаче нет скрытых тестов - все тесты публичные (string_view_public_test.cpp).

C*. Дек
Ограничение времени	1 секунда
Ограничение памяти	63.9 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Реализуйте тип данных "дек", который поддерживает следующие операции:

push_front — Добавить (положить) в начало дека новый элемент. Программа должна вывести ok.
push_back — Добавить (положить) в конец дека новый элемент. Программа должна вывести ok.
pop_front — Извлечь из дека первый элемент. Программа должна вывести его значение.
pop_back — Извлечь из дека последний элемент. Программа должна вывести его значение.
front — Узнать значение первого элемента (не удаляя его). Программа должна вывести его значение.
back — Узнать значение последнего элемента (не удаляя его). Программа должна вывести его значение.
size — Вывести количество элементов в деке.
clear — Очистить дек (удалить из него все элементы) и вывести ok.
exit — Программа должна закончить свою работу и вывести bye.
Если во входных данных встречается операция pop_front, pop_back, front, back, и при этом дек пуст, то программа должна вместо числового значения вывести строку error.

Формат ввода
В первой строке вводится целое число K (1 ≤ K ≤ 10^5) — количество команд управления деком.

Далее в каждой новой строке вводятся команды управления деком, по одной на строке.

Формат вывода
Требуется вывести протокол работы дека, по одному сообщению на строке.

D. MinQueue
Ограничение времени	1 секунда
Ограничение памяти	64Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Реализуйте тип данных «очередь c поддержкой минимума», который поддерживает следующие операции:

«enqueue n» Добавить в хвост очереди число n (1 ≤ n ≤ 109) (значение n задается после команды). Программа должна вывести «ok».
«dequeue» Удалить из очереди головной элемент. Программа должна вывести его значение.
«front» Программа должна вывести значение головного элемента, не удаляя его из очереди.
«size» Программа должна вывести количество элементов в очереди.
«clear» Программа должна очистить очередь и вывести «ok».
«min» Программа должна вывести минимум в очереди, не удаляя его из очереди.
Если во входных данных встречается операция «front», «dequeue» или «min», и при этом очередь пуста, то программа должна вместо числового значения вывести строку «error».

Формат ввода
В первой строке входных данных записано единственное число M (1 ≤ M ≤ 2 ⋅ 105) — количество команд. В следующих М строках дано по одной команде из тех, что идут выше.

Формат вывода
Для каждой команды выведите одну строчку — результат ее выполнения.

E. Пирамидальная сортировка. Шаблоны
Ограничение времени	1 секунда
Ограничение памяти	256Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Реализуйте две шаблонные функции:

MakeHeap(begin, end), которая принимает указатель на начало и конец последовательности (напомним, конец последовательности - элемент следующий за последним) и переупорядочивает элементы так, чтобы последовательность образовала max-пирамиду.
SortHeap(begin, end), которая принимает указатель на начало и конец max-пирамиды и сортирует элементы с помощью пирамидальной сортировки.
Пример:

int arr[3, 1, 4, 1, 5, 9];

MakeHeap(arr, arr + 6); // arr == [9, 4, 5, 1, 1, 3]

SortHeap(arr, arr + 6); // arr == [1, 1, 3, 4, 5, 9]

В качестве решения пришлите заголовочный файл с определением шаблонов. main писать не нужно - обработка ввода и вывода будет производиться автоматически!

Формат ввода
В первой строке вводится число N — размер массива (1 ≤ N ≤ 105), во второй идут N целых чисел, не превосходящих по модулю 109.

Формат вывода
Выведите отсортированный массив, его элементы необходимо разделять пробелами.

F. Карточная игра
Ограничение времени	0.2 секунды
Ограничение памяти	64Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
В игре в зожника карточная колода раздается поровну двум игрокам. Далее они вскрывают по одной верхней карте, и тот, чья карта старше, забирает себе обе вскрытые карты, которые кладутся под низ его колоды. Тот, кто остается без карт — проигрывает.
Для простоты будем считать, что все карты различны по номиналу, а также, что самая младшая карта побеждает самую старшую карту («шестерка берет туза»).
Игрок, который забирает себе карты, сначала кладет под низ своей колоды карту первого игрока, затем карту второго игрока (то есть карта второго игрока оказывается внизу колоды).
Напишите программу, которая моделирует игру в зожника и определяет, кто выигрывает. В игре участвует 5 карт, имеющих значения от 0 до 9, большая карта побеждает меньшую, карта со значением 0 побеждает карту 9.

Формат ввода
Программа получает на вход две строки: первая строка содержит 5 чисел, разделенных пробелами — номера карт первого игрока, вторая — аналогично 5 карт второго игрока. Карты перечислены сверху вниз, то есть каждая строка начинается с той карты, которая будет открыта первой.
Формат вывода
Программа должна определить, кто выигрывает при данной раздаче, и вывести слово «ﬁrst» или «second», после чего вывести количество ходов, сделанных до выигрыша. Если на протяжении 
1
0
6
 ходов игра не заканчивается, программа должна вывести слово «botva».

 G. Трехвидовая ПСП
Ограничение времени	1 секунда
Ограничение памяти	64Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Скобочная последовательность состоит из следующих видов скобок: (, ), [, ], {, }. Проверьте является ли введенная скобочная последовательность правильной.

Формат ввода
Дана скобочная последовательность из символов выше длиной не более 105.

Формат вывода
Выведите YES, если скобочная последовательность правильная, и NO — иначе.

H. Польская запись
Ограничение времени	0.2 секунды
Ограничение памяти	64Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
В постфиксной записи (или обратной польской записи) операция записывается после двух операндов. Например, сумма двух чисел 
A
 и 
B
 записывается как «A B +». Запись «B C + D *» обозначает привычное нам «(B + C) * D», а запись «A B C + D * +» означает «A + (B + C) * D».
Достоинство постфиксной записи в том, что она не требует скобок и дополнительных соглашений о приоритете операторов для своего чтения.

Формат ввода
В единственной строке записано выражение в постфиксной записи, содержащее однозначные числа и операции «+, -, *».
Формат вывода
Необходимо вывести значение записанного выражения.

I. Минимум на отрезке
Ограничение времени	1 секунда
Ограничение памяти	64.8 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Рассмотрим последовательность целых чисел длины 
N
N. По ней с шагом 
1
1 двигается "окно" длины 
K
K, то есть сначала в "окне" видно первые 
K
K чисел, на следующем шаге в "окне" уже будут находиться 
K
K чисел, начиная со второго, и так далее до конца последовательности. Требуется для каждого положения "окна" определить минимум в нём.

Формат ввода
В первой строке входных данных содержатся два числа 
N
N и 
K
K (
1
≤
N
≤
150000
1≤N≤150000, 
1
≤
K
≤
10000
1≤K≤10000, 
K
≤
N
K≤N) -- длины последовательности и "окна", соответственно. На следующей строке находятся 
N
N чисел -- сама последовательность.

Формат вывода
Выходные данные должны содержать 
N
−
K
+
1
N−K+1 строк -- минимумы для каждого положения "окна".

J. Гоблины
Ограничение времени	1 секунда
Ограничение памяти	64Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Гоблины Мглистых гор очень любях ходить к своим шаманам. Так как гоблинов много, к шаманам часто образуются очень длинные очереди. А поскольку много гоблинов в одном месте быстро образуют шумную толку, которая мешает шаманам проводить сложные медицинские манипуляции, последние решили установить некоторые правила касательно порядка в очереди.
Обычные гоблины при посещении шаманов должны вставать в конец очереди. Привилегированные же гоблины, знающие особый пароль, встают ровно в ее середину, причем при нечетной длине очереди они встают сразу за центром.
Так как гоблины также широко известны своим непочтительным отношением ко всяческим правилам и законам, шаманы попросили вас написать программу, которая бы отслеживала порядок гоблинов в очереди.

Формат ввода
В первой строке входных данный записано число 
N
(
1
≤
N
≤
1
0
5
)
 — количество запросов к программе. Следующие N строк содержат описание запросов в формате:
«+ i» — гоблин с номером 
i
(
1
≤
i
≤
N
)
 встает в конец очереди;
«* i» — привилегированный гоблин с номером 
i
 встает в середину очереди;
«-» — первый гоблин из очереди уходит к шаманам. Гарантируется, что на момент такого запроса очередь не пуста.
Формат вывода
Для каждого запроса типа «-» программа должна вывести номер гоблина, который должен зайти к шаманам.