A. Iterops
Ограничение времени	0.2 секунд
Ограничение памяти	16.0 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt

Iterops
Наличие итераторов различных категорий усложняет написание обобщенного кода, так как операции поддерживаемые одним типом могут не поддерживаться другим. В частности, random access итераторы могут быть продвинуты на несколько шагов вперед за O(1) с помощью +=, в то время как для bidirectional итераторов необходимо в цикле вызывать ++. К счастью, в стандартной библиотеке есть функции, которые позволяют единым образом работать со всеми итераторами и выбирают наиболее эффективный способ выполнения той или иной операции на основании категории итератора.

std::advance, std::next, std::prev, std::distance
Функция std::advance принимает итератор и количество шагов, на которое нужно его продвинуть. При этом для random access итераторов используется +=, а для остальных цикл из ++ (или --).

Функция std::next аналогична std::advance, но может быть вызвана без второго аргумента (продвигает итератор на 1) и не изменяет исходный итератор, а возвращает новый.

Функция std::prev аналогична std::next, но двигает итераторы в обратном направлении (--).

Функция std::distance принимает пару итераторов (начало и конец последовательности) и вычисляет расстояние между ними. Для random access итераторов работает за O(1), так как использует вычитание одного итератора из другого, для остальных сложность линейная (продвигаем начало пока не встретим конец).

Пример:

std::vector<int> v{1, 2, 3, 4, 5};
std::list<int> l{1, 2, 3, 4, 5};

auto v_it = v.begin();
auto l_it = l.begin();

std::advance(v_it, 3);  // <=>  v_it += 3
std::advance(l_it, 3);  // <=>  for (int i = 0; i < 3; ++i) { ++l_it; }

auto vv_it = std::next(v_it, 2);
auto ll_it = std::next(l_it, 2);

std::cout << std::distance(v_it, vv_it);  // 2  O(1)
std::cout << std::distance(l_it, ll_it);  // 2  O(distance)
Задание
Реализовать шаблонные функции Advance, Next, Prev, Distance (аналоги функций выше) с механизмом диспетчеризации по типу переданного итератора.

Детали реализации
Категорию итератора можно получить с помощью класса std::iterator_traits: она определена в типе-члене iterator_category.

using IteratorType = typename std::vector<T>::iterator;  // вспомните, зачем нужен typename
std::iterator_traits<IteratorType>::iterator_category category;  // category имеет тип std::random_access_iterator_tag
Как с помощью этой информации реализовать требуемый функционал? Наивная реализация не пройдет:

if (std::iterator_traits<IteratorType>::iterator_category == std::random_access_iterator) {  // 1
  iterator += n;  // 2
} else {
  for (int i = 0; i < n; ++i) {
    ++iterator;
  }
}
Во-первых, типы нельзя сравнивать с помощью == (по сути, в 1 написано что-то наподобие int == float). Во-вторых, если итератор не поддерживает операцию +=, то вы получите ошибку компиляции (компилируются обе ветки if и в одной из них написано что-то некорректное).

Для решения этих проблем в данной задаче предлагается использовать механизмы метапрограмирования из C++17, а именно: * constexpr if позволяет "отключать" ветки инстанцирования при выполнении переданных compile-time условий; * std::is_same/std::is_same_v предоставляет аналог операции сравнения на равенство для типов; * наконец, если требуется не точная проверка соответствия типа, а, например, проверка на то, является ли один тип наследником другого, то можно воспользоваться std::is_base_of/std::is_base_of_v.

B. IsPrime(CompileTime)
Ограничение времени	0.2 секунд
Ограничение памяти	16.0 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt

Compile Time Prime
В этом задании мы немного поностальгируем и реализуем алгоритм проверки числа на простоту. Но уже на этапе компиляции.

Подзадача 1. Квадратный корень
Для начала научимся искать целочисленный квадратный корень произвольного неотрицательного числа N. То есть наибольшее неотрицательное число S, что S * S <= N. Простой перебор значений является неэффективной стратегией, а также в случае метапрограммирования на шаблонных параметрах приведет к очень глубокой рекурсии. Поэтому решать задачу будем с помощью бинарного поиска.

Реализуйте бинарный поиск во время компиляции, который определит целочисленный квадратный корень числа N. Результат должен храниться в шаблонной переменной kSqrtV<N>.

Подсказка: не инстанцируйте лишние шаблоны. То есть убедитесь, что ветки поиска, которые ведут в отброшенные части отрезка, не инстанцируются.

Подзадача 2. Поиск делителей на подотрезке
Теперь нужно реализовать перебор значений на этапе компиляции и определение наличия/отсутствия делителей. В примитивном случае все довольно просто - цикл на шаблонах = рекурсия. Но в случае большого отрезка мы снова упираемся в ограничение на глубину рекурсии. Поэтому воспользуемся стратегией "разделяй и властвуй". Поиск делителей на отрезке = поиск делителей на первой половине + поиск делителей на второй половине. Случай, когда отрезок состоит из одного элемента тривиален. С помощью такого необычного (с точки зрения обычного программирования) перебора мы уменьшим максимальную глубину рекурсии с линейной до логарифмической.

Реализуйте описанную процедуру определения наличия делителя числа N на отрезке [L, R] во время компиляции. Результат должен храниться в шаблонной переменной kHasDivisorOnV<N, L, R>

Подзадача 3. Проверка на простоту
Используя значения из предыдущих пунктов, определите шаблонную переменную kIsPrimeV<N>, которая определяет является ли число N простым во время компиляции.

Замечание. Все пункты можно решить просто и легко с помощью constexpr функций. Однако в этом задании их использование запрещено и ожидается решение с помощью механизма специализации шаблонов чтобы жизнь медом не казалась для учебных целей.

C. Array Traits
Ограничение времени	0.15 секунд
Ограничение памяти	16.0 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt

Array Traits
*Метапрограммирование на шаблонах позволяет проверять свойства типов данных на этапе компиляции, а также изменять типы по необходимости. Например, известно, что T - это ссылка на другой тип (допустим, int&). Как получить тот же тип T, но без ссылочной аннотации, например, для того, чтобы можно было объявить вектор таких элементов (массивы ссылок, как известно, запрещены).

В этом задании вы попрактикуетесь в написании собственных определителей и модификаторов свойств типов.*

<type_traits>
Заголовочный файл <type_traits> содержит большое количество предопределенных классов/псевдонимов/переменных, которые решают задачу обнаружения/изменения свойств типов, а также несколько служебных сущностей, которые позволяют упростить написание своих собственных классов.

Со всеми ними полезно ознакомиться, однако в этом задании разрешено использовать только std::integral_constant, std::bool_constant, std::true_type, std::false_type, std::conjunction, std::disjunction.

Задание
Реализуйте свои собственные определители/модификаторы типов для массивов:

Шаблонную переменную kIsArrayV<T>, которая определяет, является ли тип T массивом;
Шаблонную переменную kRankV<T>, которая хранит общий ранг массива (количество размерностей);
Шаблонную переменную kSizeV<T>, которая хранит размер массива (на верхнем уровне);
Шаблонную переменную kTotalSizeV<T>, которая хранит общий размер массива, включая все вложенные подмассивы;
Шаблонный псевдоним RemoveArrayT<T>, который задает низлежащий тип массива (на верхнем уровне);
Шаблонный псевдоним RemoveAllArraysT<T>, который задает тип, полученный после отбрасывания всех вложенных массивов.
Примеры применения доступны в файле с тестами

Замечание. в решении можно использовать только описанные выше служебные классы из std. Если необходимо что-то дополнительное, реализуйте это самостоятельно.

D. Iterator Traits
Ограничение времени	0.15 секунд
Ограничение памяти	16.0 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt

Iterator traits
Понимание того, какого типа итератор, играет важную роль в написании эффективного обобщенного кода. В языке C++ эта задача решается с помощью специального класса std::iterator_traits, который определяет внутренний тип iterator_category. Правда для его работы (до C++20) требуется определить соответствующие внутренние типы в самом классе итератора (либо специализировать std::iterator_traits). В этом задании мы реализуем свои версии определителей категорий итераторов на основе их синтаксических свойств, с помощью механизма SFINAE.

SFINAE
TODO

Задание
Необходио реализовать следующие шаблонные переменные:

kIsDereferenceableV<T>
применима ли операция разыменования (*) к объекту типа T;
kIsIncrementableV<T>
применимы ли операции инкремента (префиксного и постфиксного ++) к lvalue типа T;
kIsDecrementableV<T>
применимы ли операции декремента (префиксного и постфиксного --) к lvalue типа T;
kIsArrowDereferenceableV<T>
применима ли операция косвенного доступа (->) к объекту типа T (будем считать, что данная операция применима ко всем указателям и классам с перегруженной операцией ->);
kIsEqualityComparableV<T>
применима ли операция сравнения на равенство (==) к объектам типа T, и приводим ли результат операции к типу bool (проверять существование операции != не требуется);
kIsOrderedV<T>
применима ли операция сравнения на меньше (<) к объектам типа T, и приводим ли результат операции к типу bool (проверять существование других операций не нужно);
kIsSubtractableV<T>
применима ли операция разности (-) к объектам типа T. Также определите шаблонный псевдоним DifferenceType<T>, который совпадает с типом результата разности объектов типа T;
kHasIntegralArithmeticV<T>
применимы ли операции присваивающей суммы и вычитания (+=, -=) к lvalue типа T слева и DifferenceType<T> справа, и является ли DifferenceType<T> целочисленным типом;
kIsSubscriptableV<T>
применима ли операция доступа по индексу ([]) к объекту типа T и DifferenceType<T>, и является ли DifferenceType<T> целочисленным типом;
kIsIteratorV<T>
является ли тип T итератором, а именно: будем считать тип итератором, если он 1) имеет конструктор копирования, 2) имеет копирующее присваивание, 3) имеет деструктор, 4) имеет операцию разыменования, 5) имеет операции инкремента;
kIsInputIteratorV<T>
принадлежит ли тип T категории Input Iterator, а именно: будем считать тип итератором ввода, если он 1) является итератором, 2) сравним на равенство, 3) имеет операцию ->;
kIsForwardIteratorV<T>
принадлежит ли тип T категории Forward Iterator, а именно: будем считать тип прямым итератором, если он 1) является итератором ввода, 2) имеет конструктор по умолчанию;
kIsBidirectionalIteratorV<T>
принадлежит ли тип T категории Bidirectional Iterator, а именно: будем считать тип двунаправленным итератором, если он 1) является прямым итератором, 2) имеет операции декремента;
kIsRandomAccessIteratorV<T>
принадлежит ли тип T категории Random Access Iterator, а именно: будем считать тип итератором, если он 1) яаляется двунаправленным итератором, 2) имеет операцию вычитания, 3) имеет операции присваивающих суммы и вычитания, 4) имеет операцию доступа по индексу, 4) имеет операцию сравнения на меньше.
При реализации разрешается пользоваться сущностями из <type_traits>.

E. Type Vector

Ограничение времени	0.15 секунд
Ограничение памяти	16.0 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt

Type Vector
В этой задаче неободимо реализовать вектор, который хранит... типы. То есть организовать хранение последовательности типов с реализованными операциями доступа к элементам, изменения последовательности, изменения типов, сортировки... И все это на этапе компиляции!

Первый уровень (обязательная часть)
Организуем хранение типов с помощью шаблонной структуры TypeVector. Эта структура может быть параметризована произвольным количеством типов (шаблон с переменным числом аргументов), которые и будут являться "элементами" вектора. Так как нас интересуют не значения, а только типы, эта структура может быть пустой (хотя при необходимости можете добавить какую-нибудь информацию в ее тело).

С помощью механизма шаблонной специализации реализуйте следующие шаблонные структуры, задающие операции над вектором типов: * Size<TV>, которая в поле value хранит число элементов в векторе TV; * Empty<TV>, которая в поле value хранит флаг, пуст ли вектор TV; * Front/Back<TV>, которые содержат тип-член type с первым/последним типом в векторе TV (если вектор пуст, то type быть не должно); * At<TV, Idx>, которая содержит тип-член type с элементом, стоящим на позиции Idx (0-индексация) в векторе TV (если вектор пуст, то type быть не должно); * Contains<TV, T>, которая в поле value хранит флаг, содержит ли вектор TV элемент T; * Count<TV, T>, которая в поле value хранит количество элементов T в векторе TV; * PushFront/PushBack<TV, T>, которая содержит тип-член type с вектором, полученным в результате добавления типа T в начало/конец вектора TV; * PopFront/PopBack<TV>, которая содержит тип-член type с вектором, полученным в результате удаления элемента из начала/конца вектора TV (если вектор пуст, то type быть не должно); * Concatenate<TV1, TV2>, которая содержит тип-член type с вектором, полученным в результате конкатенации векторов TV1 и TV2;

Также для всех структур с value определите шаблонную переменную k***V с соответствующим значением, а для структур с type - псевдоним ***T с соответствующим типом, где *** - имя структуры.

Примеры применения ищите в файле с тестами.

Второй уровень (дополнительная часть 1)
Реализуйте простейшие алгоритмы (в виде шаблонных структур) для работы с вектором типов, а именно:

Insert<TV, Idx, T>, которая содержит тип-член type с вектором, полученным в результате вставки типа T в позицию Idx (0-индексация) вектора TV (если Idx совпадает с размером вектора, то вставка осуществляется в конец вектора, если Idx выходит за границы массива, то type быть не должно);
EraseFirst<TV, T>, которая содержит тип-член type с вектором, полученным в результате удаления первого с начала типа T из вектора TV;
EraseAll<TV, T>, которая содержит тип-член type с вектором, полученным в результате удаления всех типов T из вектора TV;
Reverse<TV>, которая содержит тип-член type с вектором, полученным в результате разворота вектора TV;
Unique<T>, которая сожержит тип-член type с вектором, содержащим только уникальные типы из TV (с сохранением относительного порядка).
Transform<TV, F>, которая содержит тип-член type с вектором, полученным в результате применения шаблона F к каждому типу из TV (F<T> задает обновленный тип, где T
старый элемент вектора).
AllOf<TV, Predicate>, которая в поле value хранит флаг, верно ли, что Predicate<T>::value истина для всех T из TV;
AnyOf<TV, Predicate>, которая в поле value хранит флаг, верно ли, что Predicate<T>::value истина для какого-нибудь T из TV;
Также для всех структур с value определите шаблонную переменную k***V с соответствующим значением, а для структур с type - псевдоним ***T с соответствующим типом, где *** - имя структуры.

Примеры применения ищите в файле с тестами.

Третий уровень (дополнительная часть 2)
Реализуйте алгоритмы, основанные на сравнении элементов вектора типов. Как сравниваются типы? - Да очень просто, может быть очень много критериев. Например, по числу уровней косвенности (указателей), по размеру (sizeof), по иерархии наследования (предок-потомок). Сортировка по этим критериям может пригодиться, например, для более эффективной генерации кода/классов (известно, в частности, что расположение полей в структуре в порядке убывания размера, как правило, приводит к меньшему размеру самой структуры).

Всюду ниже предполагается, что Compare - шаблон структуры, принимающий два параметра-типа и имеющий статическое поле value, которое хранит флаг, верно ли что первый тип меньше второго.

MinElement<TV, Compare> содержит тип-член type с элементом вектора TV, который не больше остальных (если вектор пуст, то type быть не должно);
MaxElement<TV, Compare> содержит тип-член type с элементом вектора TV, который не меньше остальных (если вектор пусть, то type быть не должно);
Merge<TV1, TV2, Compare> содержит тип-член type с вектором, полученным в результате слияния отсортированных векторов TV1 и TV2 (согласно сравнению Compare);
Sort<TV, Compare> содержит тип-член type с отсортированной версией вектора TV.
Для всех структур определите псевдоним ***T с соответствующим низлежащим типом type, где *** - имя структуры.

Примеры применения ищите в файле с тестами.

F. Itertools.Zip
Ограничение времени	0.15 секунд
Ограничение памяти	16.0 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt

Itertools
Одним из минусов языка C++ является отсутствие удобного интерфейса работы с последовательностями и промежутками значений, который, по большому счету сводится к ручному написанию циклов и работе со встроенными итераторами. С введением библиотеки в C++20 ситуация заметно улучшилась. В этом цикле задач мы попытаемся решить заявленную проблему средствами C++17.

Zip
Для одновременного прохода по нескольким контейнерам приходится вручную поддерживать итераторы на каждый из них:

auto fit = first.begin();
auto sit = second.begin();
for (; fit != first.end() && sit != second.end(); ++fit, ++sit) {
    // ...
}
Сравните, например, с языком Python: python for x, y in zip(first, second): # ...

Хотелось бы иметь подобный лаконичный код и в C++ (благо range-based for завезли в C++11):

for (auto&& [x, y] : zip(first, second)) {
    // ...
}
Проблема в том, что в стандартной библиотеке (до C++20) нет сущности zip, которую можно было использовать в подобном контексте. Ну а раз так - надо ее реализовать самостоятельно!

Детали реализации
Необходимо реализовать Zip (класс или функцию), который возвращает объект некоторого класса (вам нужно его реализовать) с определенными методами begin и end. Эти методы должны возвращать итераторы, которые при разыменовании возвращают набор результатов (std::tuple) разыменования итераторов переданных контейнеров.

Примеры: (больше примеров см. в тестах)

std::list<int> l{1, 2, 3, 4, 5};
std::vector<double> v{1.0, 2.0, 3.0, 4.0};

for (auto&& [x, y] : Zip(l, v)) { ... };  // [x, y] in {[1, 1.0], [2, 2.0], [3, 3.0], [4, 4.0]}

for (auto&& [x, y] : Zip(l, v)) {
    x = 1;
    y = 0;
}
// l == {1, 1, 1, 1, 5}
// v == {0, 0, 0, 0}
Указание: вспомните как работает range-based for в C++.

Дополнительная часть
Пожержите работу Zip с временными контейнерами. Добавьте директиву #define TEMPORARY_ZIP_IMPLEMENTED, если реализовали данную часть.

G. LRU.Problem
Ограничение времени	1 секунда
Ограничение памяти	16.0 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt

Задача для отправки решений (не тестов)! Ожидается файл lru.h

LRU
Это задача-"соревнование" --- в ней вам предстоит не просто предъявить решение, но и написать тесты к нему. Количество баллов за нее зависит от корректности вашего решения и количества решений, которые не прошли ваши тесты.

LRU Map
Идея кэширования результатов довольно популярна и широко применяется в ситуациях, когда вычисление этого самого результата может тратить довольно существенное время (или иной вид ресурса). Кратко напомним подход: результаты запросов сохраняются в специальной структуре данных, из которой их в любой момент можно достать. Однако проблема в том, что при достаточно большом числе запросов размер кэша будет играть немаловажную роль в эффективности работы системы (как по времени, так и по памяти). В связи с этим необходимо озаботиться стратегией поддержания размера кэша в разумных рамках, что включает в себя как алгоритм выбора объектов для хранения в кэше, так и алгоритм вытеснения потенциально не нужных данных.

Одной из наиболее часто используемых стратегий является LRU (Least Recently Used). Эта стратегия в первую очередь вытесняет те элементы, которые были не востребованы дольше всего. Одним из вариантов реализации подхода может быть следующий.

Кэш представляет собой контейнер фиксированного размера. При запросе сначала результат ищется в кэше, и если он найден, то он возвращается и поднимается в списке недавно используемых элементов на первое место. Если же результата в кэше не обнаружено, то он вычисляется, а затем кладется в кэш. При этом, если в момент добавления кэш уже заполнен полностью, то из него удаляется элемент, к которому не обращались дольше всего.

Детали реализации
Реализуйте шаблонную структуру данных LRUMap<Key, Value>, которая представляет собой ассоциативный массив ограниченного размера (отображение запросов - Key в результаты - Value). При добавлении элемента сверх допустимого размера, она должна удалять самый "старый" из своих элементов (согласно стратегии LRU).

Структура должна поддерживать следующие операции (функционал может дополняться и уточняться в зависимости от поступивших вопросов): * Конструктор от максимального размера. Принимает целое положительное число - максимальный размер контейнера. * Методы Size, Empty, Capacity - текущий размер, пустой ли контейнер, максимально допустимый размер. * Метод void Add(key, value), который добавляет в контейнер значение value, соответсвующее ключу key. Если ключ key уже лежит в мапе, то необходимо обновить value. Пара (key, value) при этом (в любом случае) считается наиболее недавно использованной. * Метод bool Contains(key), который проверяет наличие ключа key в мапе. При наличии элемент считается наиболее недавно использованным. * Метод Get(key), который возвращает ссылку на найденное значение по ключу key и помечает его наиболее недавно использованным. При отсутствии элемента необходимо бросить исключение std::out_if_range. * Метод GetOr(key, default_value), который возвращает найденное значение по ключу key и помечает его наиболее недавно использованным. При отсутствии элемента необходимо вернуть default_value (значение в мапу при этом не добавляется). * Метод Erase(key), который удаляет элемент при его наличии (при отсутствии ничего не происходит). * Метод Clear(), который очищает мапу от элементов. * Копирование и перемещение структуры должно работать корректно.

Можно считать, что типы Key и Value копируемы и noexcept-перемещаемы, для элементов типа Key определены операции взятия хеша std::hash<Key> и сравнения (==, !=, <, ...).

При возникновении вопросов по функционалу структуры пишите в чат. В файле lru_public_test.cpp содержится лишь заготовка тестов к задаче. Свои тесты располагайте в этом же файле. Можете дополнить существующие тесты, либо же переписать под свои нужды. Старайтесь разделять тесты на логические секции. Тесты должны соответствовать условию задачи -- проверка условий, методов, которые не описаны в текущем файле недопустима, такие файлы с тестами будут проигнорированы. Вы можете включить в тесты проверку эффективности решений (256MB/1s в Я.Контесте). Обратите внимание, что тесты будут запускаться с санитайзерами. Заведомо непроходимые тесты будут баниться. Не нужно подбирать тесты максимально близкие к ограничениям, старайтесь поймать решения с плохой асимптотикой.

Написание тестов и реализация решения - разные задания. Теоретически можно отправить только одно из них (либо ни одно из них). Но проверять работоспособность решения без тестов и наоборот будет крайне проблематично.